<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Nginx location的root问题</title>
      <link href="/2020/06/13/nginx-location-de-root-wen-ti/"/>
      <url>/2020/06/13/nginx-location-de-root-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p>location root属性会对拦截的路径进行拼接如</p><p>当location拦截路径为 /test/时<br>客户端请求连接为 <a href="http://localhost/test/aa/1.txt" target="_blank" rel="noopener">http://localhost/test/aa/1.txt</a><br>而root 为 /var/ss<br>最终结果为 /var/ss/test/1.txt<br>此时会将/test/之后包括/test/添加到test之后</p><p>当location拦截路径为/时<br>客户端请求连接为 <a href="http://localhost/test/aa/1.txt" target="_blank" rel="noopener">http://localhost/test/aa/1.txt</a><br>root设置为 /var/ss<br>最后结果为/var/ss/test/aa/1.txt<br>此时会将除<a href="http://localhost外所有拼接到root路径后" target="_blank" rel="noopener">http://localhost外所有拼接到root路径后</a></p><p>当按文件名进行匹配时，当页面链接如 href= css/a.css时<br>此时当发送请求时浏览器会自动添加其项目名<br><br><br>该请求链接完整是<font color ='red'> http:/地址/项目名/css/a.css</font><br><br>当root路径为/var/ss或http:localhost/<br><br>此时真实路径为/var/ss/css/a.css<br><br>nginx会将请求除http:/地址/之外的所有添加到root后面<br><br>所以最后结果为 /var/ss/项目名/css/a.css<br><br>这时真实路径下/css/a.css在ss文件夹下，并不在项目名文件夹下，所以浏览器会获取不到，需要在/ss/目录下创建和该项目同名的文件这是才会和最终路径匹配</p>]]></content>
      
      
      <categories>
          
          <category> Web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx使用</title>
      <link href="/2020/06/06/nginx-shi-yong/"/>
      <url>/2020/06/06/nginx-shi-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>访问nginx,但是nginx把请求交给tomcat来做</p><p>然后修改nginx.conf，主要是30-42行</p><pre><code>        location / {            proxy_pass http://127.0.0.1:8111;    }    //location / 表示处理所有请求    //proxy_pass http://127.0.0.1:8111; 表示把请求都交给http://127.0.0.1:8111来处理</code></pre><h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p>css, js之类的都交给nginx来处理，nginx处理不了的，比如jsp 就交给tomcat来处理~</p><p>在locaction下面添加一个新的location:</p><pre><code>        location ~\.(css|js|png)$ {            root C:/Users/X7TI/Downloads/tomcat_8111/webapps/ROOT;            }    //这表示所有的css js png访问都由nginx来做，访问的地址是    //C:/Users/X7TI/Downloads/tomcat_8111/webapps/ROOT    //这里要注意，填写本地地址的时候，要用正斜杠 / 不要用反斜杠 \</code></pre><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>负载均衡的概念就是当访问量很大的时候，一个 Tomcat 吃不消了，这时候就准备多个 Tomcat，由Nginx按照权重来对请求进行分配，从而缓解单独一个Tomcat受到的压力</p><p>首先增加一个upstream ，用来指向这两个tomcat</p><pre><code>  upstream tomcat_8111_8222{    server    127.0.0.1:8111 weight=1;    server    127.0.0.1:8222 weight=2;    }</code></pre><p>然后修改location，反向代理到上述配置。</p><pre><code>        location / {            proxy_pass http://tomcat_8111_8222;    }</code></pre><p>weight表示权重，值越大，被分配到的几率越大</p><h2 id="session共享"><a href="#session共享" class="headerlink" title="session共享"></a>session共享</h2><p>将session信息存到rides中需要取的时候，也从Redis上取。</p>]]></content>
      
      
      <categories>
          
          <category> Web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis</title>
      <link href="/2020/06/05/redis/"/>
      <url>/2020/06/05/redis/</url>
      
        <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ol><li>字符串类型String</li><li>哈希类型 hash：map格式</li><li>列表类型list：linkedlist格式</li><li>集合类型set：</li><li>有序集合类型sortedset</li></ol><h1 id="常用存储操作"><a href="#常用存储操作" class="headerlink" title="常用存储操作"></a>常用存储操作</h1><p>文档：<a href="http://www.redis.cn/commands.html" target="_blank" rel="noopener">http://www.redis.cn/commands.html</a></p><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><ol><li>存储：set key valu</li><li>获取：get key</li><li>删除：del key<h2 id="哈希类型"><a href="#哈希类型" class="headerlink" title="哈希类型"></a>哈希类型</h2></li><li>存储：hset key field value</li><li>获取：hget key field</li><li>删除：hdel key<h2 id="列表类型"><a href="#列表类型" class="headerlink" title="列表类型"></a>列表类型</h2></li><li>将元素加入类别左边：lpush key value</li><li>将元素加入类别右边：rpush key value</li><li>获取<ul><li>lrange key start end：范围获取</li></ul></li><li>删除<ul><li>lpop key:删除列表最左边元素，并将元素返回</li><li>rpop key:删除列表最右边元素，并将元素返回<h2 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h2></li></ul></li><li>存储：sadd key value</li><li>获取所有元素：smember key</li><li>删除某个元素：srem key value<h2 id="有序集合类型"><a href="#有序集合类型" class="headerlink" title="有序集合类型"></a>有序集合类型</h2></li><li>存储：zadd key score value</li><li>获取：zrange key start end</li><li>删除：zren key value<h2 id="通用类型"><a href="#通用类型" class="headerlink" title="通用类型"></a>通用类型</h2></li><li>查询所有键：keys *</li><li>获取键对应的value的类型：type key</li><li>删除指定的key value：del key</li></ol><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>redis是内存数据库，当redis服务器重启，或电脑重启数据会丢失</p><p>redis持久化机制：<br>RDB：默认方式，在一段间隔的时间中检查key变化，然后持久化<br>AOF：日志记录方式，可以每一次命令操作后持久化数据</p><h1 id="Jedis连接池"><a href="#Jedis连接池" class="headerlink" title="Jedis连接池"></a>Jedis连接池</h1><p>创建连接池对象 new JedisPool<br>获取连接 getResource</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rides </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库事务</title>
      <link href="/2020/06/05/shu-ju-ku-shi-wu/"/>
      <url>/2020/06/05/shu-ju-ku-shi-wu/</url>
      
        <content type="html"><![CDATA[<h1 id="事务属性"><a href="#事务属性" class="headerlink" title="事务属性"></a>事务属性</h1><p>原子性：是不可分割的最小单位，要么同时成功要么同时失败<br>持久性：当事务提交或回滚后，数据库会持久化的保存数据<br>隔离性：多个事务直接，相互独立（真实情况下多个事务之间会有影响）<br>一致性：事务操作前后数据总量不变</p><h1 id="mysql开始事务"><a href="#mysql开始事务" class="headerlink" title="mysql开始事务"></a>mysql开始事务</h1><p>start TRANSACTION </p><p>提交<br><br>commit<br><br>回滚<br><br>rollback <br><br>回滚会还原到开启事务之前的状态</p><font color ='red'>在mysql数据库中事务默认自动提交一条DML（增删改）语句会自动提交一次事务</font><p>修改默认提交方式<br>set @@autocommit =   0 – 代表手动提交 1 –代表自动提交</p><h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p>多个事务之间隔离的，相互独立，但如果多个事务操作同一批数据，则会引发一些问题</p><h2 id="存在问题："><a href="#存在问题：" class="headerlink" title="存在问题："></a>存在问题：</h2><p>脏读：一个事务读取到另一个书屋中没有提交的数据<br>不可重复读（虚读）：在同一个事务中两次读取到数据不一样<br>幻读：一个事务操作（DML）数据表中所有记录，另一个事务添加了一条数据，则第一个书屋查询不到自己的修改</p><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>readuncommitted：读未提交</p><ul><li>产生问题：脏读，不可重复读，幻读</li></ul><p>read committed：读已提交（Oracle默认）</p><ul><li>产生问题：不可重复读，幻读</li></ul><p>repeatable read：可重复读（mysql默认）</p><ul><li>产生问题：幻读</li></ul><p>serializable：串行化</p><ul><li>可以解决所有问题</li></ul><font color='red'>注意：隔离级别从小到大安全性越来越高，但效率越来越低</font><p>数据库设置隔离级别</p><p>set global transaction isolation level 级别字符串</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于在SSM框架使用Filter</title>
      <link href="/2020/06/01/guan-yu-zai-ssm-kuang-jia-shi-yong-filter/"/>
      <url>/2020/06/01/guan-yu-zai-ssm-kuang-jia-shi-yong-filter/</url>
      
        <content type="html"><![CDATA[<p>由于Filter创建优先于Spring的实例所以在Filter进行依赖注入是不行的需要使用拦截器</p>]]></content>
      
      
      <categories>
          
          <category> Web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合</title>
      <link href="/2020/05/31/java-ji-he/"/>
      <url>/2020/05/31/java-ji-he/</url>
      
        <content type="html"><![CDATA[<p>集合分为collection和map，<br>Collection是单列集合类的接口，<br>Map是双列集合类的接口</p><h1 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h1><p>collection实现接口有：List  ，Set，Queue</p><p>注：在jdk1.5后添加的Queue</p><h2 id="Collection常用方法"><a href="#Collection常用方法" class="headerlink" title="Collection常用方法"></a>Collection常用方法</h2><p><font color=#DC143C> 注意:Collection方法是没有带索引的方法的</font></p><img src="/2020/05/31/java-ji-he/collection.png" class=""><h2 id="List接口："><a href="#List接口：" class="headerlink" title="List接口："></a>List接口：</h2><ol><li><p>有序的集合</p></li><li><p>允许存储重复的元素</p></li><li><p>有索引，可以使用for循环</p></li></ol><h3 id="List集合包括：ArrayList-，LinkedList，-Vector"><a href="#List集合包括：ArrayList-，LinkedList，-Vector" class="headerlink" title="List集合包括：ArrayList ，LinkedList， Vector"></a>List集合包括：ArrayList ，LinkedList， Vector</h3><ol><li><p>ArrayList：底层是数组实现，查询快，增删慢</p></li><li><p>LinkedList：底层是链表实现的，查询慢，增删快，包含大量操作首尾元素的方法</p></li><li><p>LinkedList还有一个 push（）和pop（）方法等同于addFirst（）和removeFirst（）；</p></li><li><p>Vector：底层结构是数组，线程安全的，增删慢，查询快（不常用）</p></li></ol><p><font color=#DC143C>注意：当使用集合特有方法将无法使用多态</font></p><img src="/2020/05/31/java-ji-he/list.png" class=""><p>注：void add(int index, E element)在列表的指定位置插入指定元素（可选操作）。将当前处于该位置的元素（如果有的话）和所有后续元素向右移动（在其索引中加 1）</p><h2 id="Set接口："><a href="#Set接口：" class="headerlink" title="Set接口："></a>Set接口：</h2><ol><li>不允许存储重复元素如果添加的是已有的数据， 会用现在的值替换原来的值，并返回原来的值</li><li>没有索引，所以不能有for循环</li></ol><h3 id="Set集合包括：HashSet，-LinkedHashSet，-TreeSet"><a href="#Set集合包括：HashSet，-LinkedHashSet，-TreeSet" class="headerlink" title="Set集合包括：HashSet， LinkedHashSet， TreeSet"></a>Set集合包括：HashSet， LinkedHashSet， TreeSet</h3><p>  HashSet：底层是哈希表和红黑树实现的，无索引，不可以存储重复元素，存取无序，存储元素和取出元素可能不一致，查询速度非常快。</p><p>注：当HashSet存储自定义类型元素如String，Integer，Student，Pojo类等</p><p>需要重写hashcode（）和equals（）方法，防止出现对象属性相同但依旧可以存储的情况，应为当自定义的对象的属性相同应该视为同一个对象。</p><p>LinkedHashSet：底层是哈希表和链表实现的，无索引，不可以存储重复元素，可以保证存取顺序</p><p>TreeSet：底层是二叉树实现，一般用于排序</p><p>在jdk1.8之前 ：哈希表=数组+链表</p><p>在jdk1.8之后：哈希表=数组+链表 或 哈希表=数组+红黑树</p><h2 id="Queue接口"><a href="#Queue接口" class="headerlink" title="Queue接口"></a>Queue接口</h2><p>  由于大多数资料没有详细介绍Queue接口所以我单独写了笔记进行介绍</p><h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><p>Map集合键存储键值对，键不可以重复，但值可以重复，但一个键对应一个值</p><p>键和值的数据类型可以相同，也可以不相同</p><p>当添加重复值会替换掉原来的值会返回旧值如果之前不存在则返回null</p><p>注：在Map接口中有一个内部接口Entry，用来记录键与值</p><p>Map实现子类常用的有 HashMap， LinkedHashMap</p><p><img src="/2020/05/31/java-ji-he/map.png" class="" title="}&lt;&#x2F;p&gt; &lt;h2 id&#x3D;HashMap：&gt;&lt;a href&#x3D;#HashMap： class&#x3D;headerlink title&#x3D;HashMap：&gt;&lt;&#x2F;a&gt;HashMap：&lt;&#x2F;h2&gt;&lt;p&gt;1.HashMap集合底层是哈希表，查询速度特别快&lt;&#x2F;p&gt; &lt;p&gt;jdk1.8之前：数组+单向链表&lt;&#x2F;p&gt; &lt;p&gt;jdk1.8之后：数组+单向链表&#x2F;红黑树&lt;&#x2F;p&gt; &lt;p&gt;2.HashMap是一个无序的集合，存储元素和取出元素顺序很可能不一致&lt;&#x2F;p&gt; &lt;p&gt;注：当HashMap存储自定义类型元素作为键时，需要重写hashcode（）和equals（）方法，防止出现对象属性相同但依旧可以存储的情况，应为当自定义的对象的属性相同应该视为同一个对象。&lt;&#x2F;p&gt; &lt;h2 id&#x3D;LinkedHashMap：&gt;&lt;a href&#x3D;#LinkedHashMap： class&#x3D;headerlink title&#x3D;LinkedHashMap：&gt;&lt;&#x2F;a&gt;LinkedHashMap：&lt;&#x2F;h2&gt;&lt;p&gt;1.LinkedHashMap集合底层是哈希表+链表&lt;&#x2F;p&gt; &lt;p&gt;2.LinkHashMap集合底层是有序的集合，存储元素和取出元素顺序是一致&lt;&#x2F;p&gt; &lt;p&gt;3.LinkedHashMap可以根据访问顺序和插入顺序进行排序&lt;&#x2F;p&gt; &lt;h2 id&#x3D;HashTable：&gt;&lt;a href&#x3D;#HashTable： class&#x3D;headerlink title&#x3D;HashTable：&gt;&lt;&#x2F;a&gt;HashTable：&lt;&#x2F;h2&gt;&lt;p&gt;1.键和值都不能为null&lt;&#x2F;p&gt; &lt;p&gt;2.是线程安全的，速度慢&lt;&#x2F;p&gt;">]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/2020/05/31/er-cha-shu/"/>
      <url>/2020/05/31/er-cha-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="2-3查找树"><a href="#2-3查找树" class="headerlink" title="2-3查找树"></a>2-3查找树</h1><p>性质：</p><ol><li>任意空链接到根节点的路径长度都是相等的</li><li>4节点变换为3节点是，树的高度不会发生变化，只有当根节点是临时的4节点时，书高+1。</li><li>2-3树与普通二叉查找树最大的区别在于，普通的二叉查找树是自顶向下生长，而2-3树树自底向上生长</li></ol><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>红黑树主要是对2-3树进行编码，红黑树背后的思想是用标准的二叉查找树和一些额外的信息来表示2-3树</p><p>红链接：将两个2-结点连接起来构成一个3-结点<br>黒链接：是2-3树中的普通链接</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ol><li>红链接均为左连接</li><li>没有任何一个节点同时和两个红链接相连</li><li>该树是完美的黑色平衡，既任意空链接到根节点的路径上黑链接数量相同</li></ol><h2 id="红黑树结点API"><a href="#红黑树结点API" class="headerlink" title="红黑树结点API"></a>红黑树结点API</h2><ol><li>public Node lef:记录左子结点<br /></li><li>public Node right:记录右子结点<br/></li><li>public Key key;存储键<br/></li><li>public Value value:存储值<br/></li><li>public boolean color:由其父结点指向它的链接的颜色</li></ol><p>注：有些红黑树的结点是红色和黑色而不是链接是红色或黑色<br>红色结点代表其父结点跟当且结点的链接是红色的</p><p>根节点颜色总是黑色</p><p>当结点右链接为红色则进行左旋</p><p>当结点左连接是红色并且左连接的左连接还是红色则右旋</p><p>当右旋后结点的左右链接都为红色则进行颜色翻转左右链接变为黑色，该节点变为红色</p><h1 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h1><p>B-树是M介树则每个节点存放的值不能超过M-1个</p><p>应用于磁盘</p><h1 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h1><p>B+树和B-树一样每个节点不可超过M-1个<br>B+树的非叶子节点不存放值只存放键</p><p>应用于数据库</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存</title>
      <link href="/2020/05/30/jvm-nei-cun/"/>
      <url>/2020/05/30/jvm-nei-cun/</url>
      
        <content type="html"><![CDATA[<p>栈（虚拟机栈）：存放局部变量，并且方法的运行一定在栈中<br>堆：凡是new出来的东西都在栈中<br>方法区：存储.class相关信息，包含方法的信息<br>本地方法栈：与操作系统相关<br>程序计数器（寄存器）：与cpu相关<br>这五大内存区统称为运行时数据区<br>其中栈，程序计数器，本地方法区时线程私有的，随着线程启动而创建，而堆和方法区时共有的，随线程启动而创建</p><h2 id="程序计数器："><a href="#程序计数器：" class="headerlink" title="程序计数器："></a>程序计数器：</h2><p>记住下一条jvm指令的执行地址<br>在物理上通过cpu寄存器实现的<br>程序计数器是私有的，每个线程有自己的程序计数器不会存在内存溢出</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>线程运行需要的内存空间<br>栈是线程私有的<br>栈由栈帧组成，每个栈帧代表一次方法的调用（栈帧也可以说是每个方法的内存）每个线程只有一个活动栈帧（线程正在执行的方法）<br>注意：<br> &emsp;    1. 当方法执行完毕后会自动弹出栈，所以垃圾回收不涉及栈内存<br>   &emsp;        2. 栈可以通过调节大小，但栈越大同时运行的线程越少<br>   &emsp;      3.方法内定义的局部变量是线程安全的</p><p>   注：如果方法内局部变量没有逃离方法的作用范围，他是线程安全的如果局部变量变量引用，并逃离方法的作用范围，需要考虑线程安全</p><p>栈内存溢出：<br>&emsp;1.栈帧过多（例如递归调用没有设置好结束条件会不断调用自身并且不会结束）<br>&emsp;2.栈帧过大（很少出现）</p><h2 id="本地方法栈："><a href="#本地方法栈：" class="headerlink" title="本地方法栈："></a>本地方法栈：</h2><p>本地方法使用的内存<br>栈是线程私有的<br>本地方法（如hashcode，clone）是指不是Java代码编写的方法，由于有时候Java无法与系统层进行操作，所以会调用用c或c++编写的方法进行对系统的操作</p><h2 id="堆："><a href="#堆：" class="headerlink" title="堆："></a>堆：</h2><p>通过new关键字，创建对象都会使用堆内存<br>线程共享的，需要考虑线程安全<br>有垃圾回收机制</p><h2 id="方法区："><a href="#方法区：" class="headerlink" title="方法区："></a>方法区：</h2><p>存储类结构相关信息：成员变量，方法数据，成员方法和构造器代码，类构造器，运行时常量池）虚拟机启动时创建，逻辑上是堆的一部分（但不同厂商可能不同）（在1.8被称作元空间，放在内存中而不是jvm内，不占用堆内存）</p><p>线程共享的，需要考虑线程安全</p><p>存在内存溢出（规范规定方法区可以不实现垃圾收集）</p><h2 id="直接内存："><a href="#直接内存：" class="headerlink" title="直接内存："></a>直接内存：</h2><p>不属于JVM内存，而是操作系统的内存<br>常见与NIO操作，用于数据缓冲区分配<br>回收代价大，但读写性能高，不受JVM内存回收管理，需要自己回收。</p><p>以上为个人整理发布</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串方法</title>
      <link href="/2020/05/30/zi-fu-chuan-fang-fa/"/>
      <url>/2020/05/30/zi-fu-chuan-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>一、字符串的检索方法</p><p>1、charAt()</p><p>2、charCodeAt()</p><p>3、indexOf()</p><p>4、lastIndexOf()</p><p>chatAt()</p><p>语法：stringObject.charAt(index)</p><p>功能：返回stringObject中index位置的字符，如果没有返回空。</p><p>charCodeAt()</p><p>语法：stringObject.charCodeAt()</p><p>功能：返回stringObject中index位置的字符编码。</p><p>indexOf()</p><p>语法：stringObjet.indexOf(‘需要查找的字符’)</p><p>功能：从左往右在一个字符串中搜索给定的字符串，返回子字符串的位置。</p><p>返回值：是number值，如果不存在，就返回-1。</p><p>lastIndexOf()</p><p>语法：stringObject.lastIndexOf(‘需要查找的字符’)</p><p>功能：从右往左在一个字符串中搜索给定的字符串，返回子字符串的位置。</p><p>返回值：是number类型，如果不存在，就返回-1。</p><p>二、字符串的截取方法</p><p>1、slice()</p><p>2、substring()</p><p>3、substr()</p><p>slice()</p><p>语法：stringObject.slice(start,end)</p><p>功能：截取字符串。</p><p>参数：</p><p>start：（必须）指定子字符串的开始位置。</p><p>end：（可选）表示子字符串到哪里结束，end本身不在截取范围之内，省略不写时候直接截取至字符串末尾。</p><p>当参数为负数时候，会将传入的负值与字符串的长度相加。</p><p>substring()</p><p>语法及功能同slice()完全一样，区别只在于遇到负数时，自动将参数转换为0。</p><p>substring()会把较小的数作为开始位置，较大的数作为结束位置。</p><p>substr()</p><p>语法：stringObiect.substr(start,len)</p><p>功能：截取字符串</p><p>参数说明：</p><p>start ：（必需）指定字符串的开始位置；</p><p>len：（可选）表示截取的字符总数，省略时截取至字符串的末尾。</p><p>当start为负数时，会将传入的负值与字符串的长度相加。</p><p>当len为负数时返回空字符串。</p><p>三、字符串对象的方法</p><p>split()</p><p>replace()</p><p>split() 把一个字符串分割成字符串数组</p><p>语法：stringObject.split(separator)</p><p>返回值：Array</p><p>参数：separator（必须）分隔符</p><p>replace()</p><p>语法：stringObject.replace(regexp/substr,replacement)</p><p>功能：在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。只能替换第一个不能替换全部</p><p>返回值：string</p><p>参数：</p><p>regexp:（必需）规定子字符串或者要替换的模式的RegExp对象。</p><p>replacement:（必需）一个字符串值</p><p>注意：不会修改原字符串，会返回一个新的字符串。</p><p>四、字符串转换大小写方法</p><p>toUpperCase()</p><p>toLowerCase()</p><p>toUpperCase()</p><p>将字符串转换为大写</p><p>返回值：返回一个新字符串，不修改原字符串</p><p>toLowerCase()</p><p>将字符串转换为小写</p><p>返回值：返回一个新字符串，不修改原字符串</p><p>转载自：</p><p><a href="https://www.jianshu.com/p/3200b0e07cb5" target="_blank" rel="noopener">https://www.jianshu.com/p/3200b0e07cb5</a></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Java的常量池，运行时常量池，和串池（字符串常量池）</title>
      <link href="/2020/05/30/guan-yu-java-de-chang-liang-chi-yun-xing-shi-chang-liang-chi-he-chuan-chi-zi-fu-chuan-chang-liang-chi/"/>
      <url>/2020/05/30/guan-yu-java-de-chang-liang-chi-yun-xing-shi-chang-liang-chi-he-chuan-chi-zi-fu-chuan-chang-liang-chi/</url>
      
        <content type="html"><![CDATA[<h1 id="常量池："><a href="#常量池：" class="headerlink" title="常量池："></a>常量池：</h1><p>常量池：常量池是*.clsaa文件中的，就是一张表，存储常量符号，虚拟指令可以这些常量符号来查找类或方法或类型。</p><p>运行时常量池：当类被加载，它的常量池信息就会放入方法区的运行时常量池，并把里面的符号地址变为真实地址。</p><h2 id="StringTable（串池）hashtable结构，不能扩容："><a href="#StringTable（串池）hashtable结构，不能扩容：" class="headerlink" title="StringTable（串池）hashtable结构，不能扩容："></a>StringTable（串池）hashtable结构，不能扩容：</h2><p>在jdk1.8时串池再堆区中</p><p>jdk1.7把串池移除方法区</p><p>运行时常量池的字符串仅是符号，还没有变为对象，第一次用的才变为对象并且放入串池中</p><p>利用串池机制，来避免创建重复字符串对象</p><p>常量字符串并不会直接创建，而是引用到位置时在创建串池字符串对象</p><p>当字符串变量进行进行拼接时会创建一个stringbuilder对象（1.8）进行拼接，并调用 toString（）方法返回一个字符串对象（在堆中存储的）</p><p>当字符串常量进行拼接时会在编译期间进行优化会直接对字符串进行拼接，在运行期间在串池查找是否存在一样的字符串再返回引用</p><p>1.8中intern（）方法可以将字符串对象放入串池，如果已存在则不放入，返回串池的对象</p><p>1.6中intern（）方法方法可以将字符串对象放入串池，如果已存在则不放入，没有则将对象复制一份放入串池，返回串池的对象</p><p>在JVM1.6串池是常量池的一部分存储在方法区（永久代）内</p><p>在JVM1.7中串池放在堆中</p><p>垃圾回收:由于在常量区内会进行垃圾回收</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>StringBuilder和StringBuffer</title>
      <link href="/2020/05/30/stringbuilder-he-stringbuffer/"/>
      <url>/2020/05/30/stringbuilder-he-stringbuffer/</url>
      
        <content type="html"><![CDATA[<p>StringBuffer是线程安全的，但速度慢</p><p>StringBuilder是线程不安全，但速度快</p><p>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Web文件下载</title>
      <link href="/2020/05/30/web-wen-jian-xia-zai/"/>
      <url>/2020/05/30/web-wen-jian-xia-zai/</url>
      
        <content type="html"><![CDATA[<p>需要工具类：commons-io-2.6-bin和commons-fileupload-1.4-bin</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doPost</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">)</span> throws ServletException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>    String name <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//解决获得中文参数的乱码</span>    name <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"ISO8859-1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//美女.jpg</span>    <span class="token comment" spellcheck="true">//获得请求头中的User-Agent</span>    String agent <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token string">"User-Agent"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//根据不同浏览器进行不同的编码</span>    String fileNameEncoder <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>agent<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"MSIE"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// IE浏览器</span>        fileNameEncoder <span class="token operator">=</span> URLEncoder<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        fileNameEncoder <span class="token operator">=</span> fileNameEncoder<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"+"</span><span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>agent<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"Firefox"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 火狐浏览器</span>        BASE64Encoder base64Encoder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BASE64Encoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        fileNameEncoder <span class="token operator">=</span> <span class="token string">"=?utf-8?B?"</span> <span class="token operator">+</span> base64Encoder<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"?="</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 其它浏览器</span>        fileNameEncoder <span class="token operator">=</span> URLEncoder<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    response<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span><span class="token string">"text/html;charset=utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ServletContext servletContext <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getServletContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    InputStream fileInputStream <span class="token operator">=</span> servletContext<span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"/file/"</span><span class="token operator">+</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    String minmeType <span class="token operator">=</span> servletContext<span class="token punctuation">.</span><span class="token function">getMimeType</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">"content-type"</span><span class="token punctuation">,</span>minmeType<span class="token punctuation">)</span><span class="token punctuation">;</span>    response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">"content-disposition"</span><span class="token punctuation">,</span><span class="token string">"attachment;filename="</span><span class="token operator">+</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    OutputStream sos <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    byte<span class="token punctuation">[</span><span class="token punctuation">]</span> buff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    int len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>len <span class="token operator">=</span> fileInputStream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buff<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>buff<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        sos<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buff<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    fileInputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传</title>
      <link href="/2020/05/30/wen-jian-shang-chuan/"/>
      <url>/2020/05/30/wen-jian-shang-chuan/</url>
      
        <content type="html"><![CDATA[<p>实现文件上传必须把<from>设置为enctype=”multipart/form-data” 请求方式为post如</p><pre class=" language-javascript"><code class="language-javascript"> <span class="token operator">&lt;</span>form id<span class="token operator">=</span><span class="token string">""</span>   action<span class="token operator">=</span><span class="token string">""</span> method<span class="token operator">=</span><span class="token string">"post"</span>  enctype<span class="token operator">=</span><span class="token string">"multipart/form-data"</span><span class="token operator">></span> </code></pre><h1 id="传统文件上传"><a href="#传统文件上传" class="headerlink" title="传统文件上传"></a>传统文件上传</h1><p>需要工具类：commons-io-2.6-bin和commons-fileupload-1.4-bin</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fileUp</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//让浏览器用utf8来解析返回的数据</span>response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">"Content-type"</span><span class="token punctuation">,</span> <span class="token string">"text/html;charset=UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//告诉servlet用UTF-8转码，而不是用默认的ISO8859</span>response<span class="token punctuation">.</span><span class="token function">setCharacterEncoding</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//解决文件名</span>request<span class="token punctuation">.</span><span class="token function">setCharacterEncoding</span><span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//获取路径</span>    String path <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//判断路径是否存在</span>    File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>file<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//创建文件</span>        file<span class="token punctuation">.</span><span class="token function">mkdir</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//解析request对象，获取上传文件项</span>        DiskFileItemFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DiskFileItemFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//设置缓冲区大小</span>        factory<span class="token punctuation">.</span><span class="token function">setSizeThreshold</span><span class="token punctuation">(</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//设置临时文件路径</span>        factory<span class="token punctuation">.</span><span class="token function">setRepository</span><span class="token punctuation">(</span>tempFile<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建文件上传处理器</span>        ServletFileUpload upload <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SerletFileUpload</span><span class="token punctuation">(</span>factory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//解决上传文件名的中文乱码</span>        upload<span class="token punctuation">.</span><span class="token function">setHeaderEncoding</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//设置上传单个文件的大小的最大值，目前是设置为1024*1024字节，也就是600MB</span>        upload<span class="token punctuation">.</span><span class="token function">setFileSizeMax</span><span class="token punctuation">(</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//设置上传文件总量的最大值，最大值=同时上传的多个文件的大小的最大值的和，目前设置为1000MB</span>        upload<span class="token punctuation">.</span><span class="token function">setSizeMax</span><span class="token punctuation">(</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//解析request</span>        List items <span class="token operator">=</span> upload<span class="token punctuation">.</span><span class="token function">parseRequest</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//遍历</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>FileItem item <span class="token punctuation">:</span> items<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//进行判断，当前item对象是否是上传文件项</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span><span class="token function">isFormField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//说明是普通表的项</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//说明是上传文件项</span>                <span class="token comment" spellcheck="true">//获取上传文件名称</span>                String filename <span class="token operator">=</span> item<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//处理不同浏览器传来的文件名问题</span>                int index<span class="token operator">=</span>name<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">"\\"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>index<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    filename<span class="token operator">=</span>name<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//完成文件上传</span>                item<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span>filename<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//删除临时文件</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="SpringMVC文件上传"><a href="#SpringMVC文件上传" class="headerlink" title="SpringMVC文件上传"></a>SpringMVC文件上传</h1><p>先SpringMVC配置文件解析器</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 文件解析器<span class="token operator">--</span><span class="token operator">></span> <span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"multipartResolver"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span><span class="token operator">></span>       <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"maxUploadSize"</span> value<span class="token operator">=</span><span class="token string">"10485760"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">></span></code></pre><p>例子一</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">public</span> String <span class="token function">handler</span><span class="token punctuation">(</span>@<span class="token function">RequestParam</span><span class="token punctuation">(</span><span class="token string">"uploadfile"</span><span class="token punctuation">)</span> List uploadfile<span class="token punctuation">,</span> HttpServletRequest request<span class="token punctuation">)</span> throws IOException <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"进入servlet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>uploadfile<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>uploadfile<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//循环输出上传文件</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>MultipartFile file <span class="token punctuation">:</span> uploadfile<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//获取上传文件原始名称</span>            String filename <span class="token operator">=</span> file<span class="token punctuation">.</span><span class="token function">getOriginalFilename</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//设置保存目录</span>            String dirPath <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getServletContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getRealPath</span><span class="token punctuation">(</span><span class="token string">"/upload/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            File filePath <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>dirPath<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>filePath<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                filePath<span class="token punctuation">.</span><span class="token function">mkdirs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//重新命名上传文件名称</span>            String newFilename<span class="token operator">=</span><span class="token string">"1"</span><span class="token operator">+</span>filename<span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"上传成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//完成文件上传</span>            file<span class="token punctuation">.</span><span class="token function">transferTo</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>dirPath<span class="token operator">+</span>newFilename<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token string">"success.jsp"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>例子二</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">public</span> String <span class="token function">addProduct</span><span class="token punctuation">(</span>MultipartFile upload<span class="token punctuation">,</span> Products product<span class="token punctuation">,</span> HttpServletRequest request<span class="token punctuation">)</span> throws IOException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//文件保存路径</span>    String path <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getServletContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getRealPath</span><span class="token punctuation">(</span><span class="token string">"/client/bookcover/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//数据库保存路径</span>    String dataUrl <span class="token operator">=</span> <span class="token string">"/client/bookcover/"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//获取文件名</span>    String fileName <span class="token operator">=</span> upload<span class="token punctuation">.</span><span class="token function">getOriginalFilename</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//完成上传</span>    upload<span class="token punctuation">.</span><span class="token function">transferTo</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span>fileName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token string">"/listProduct"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网路层</title>
      <link href="/2020/05/05/wang-lu-ceng/"/>
      <url>/2020/05/05/wang-lu-ceng/</url>
      
        <content type="html"><![CDATA[<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>32位组成，分为网络号和主机号</p><h4 id="各类IP地址"><a href="#各类IP地址" class="headerlink" title="各类IP地址"></a>各类IP地址</h4><ol><li>A类地址为网络号8位开头为0，第一个可指派网络号1，最后一个可指派网络号126</li><li>B类地址网络号16位开头为10，第一个可指派网络号128.1，最后一个可指派网络号191.255</li><li>C类地址网络号24位开头为110，第一个可指派网络号192.0.1，最后一个可指派网络号223.255.255</li></ol><p>通常将8位为一组转换为10进制数</p><h4 id="特殊的IP地址"><a href="#特殊的IP地址" class="headerlink" title="特殊的IP地址"></a>特殊的IP地址</h4><ol><li>网络号全0和主机号全0，值本网络上的本主机<br>源地址可以使用，目的地址不可使用</li><li>网络号全0，指在本网络上的某台主机，源地址可以使用，目的地址不可使用</li><li>网络号全1主机号全1，指对本网络上所有主机进行广播，源地址不可使用，目的地址可以使用</li><li>主机号全1，对相应网络上的所有主机进行广播，源地址不可使用，目的地址可以使用</li><li>网络号127，主机号非全0或全1的任何数，用于本地软件的环回测试<h3 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h3>作用：从网络层使用的ip地址，解析出在数据链路层所使用的硬件地址</li></ol><p>每个主机都设有一个ARP高速缓存，里面有所在局域网上的各主机和路由器IP地址到硬件地址映射表</p><p>当主机向本局域网发送IP数据报时，先从ARP高速缓存中查看有无目的主机的IP地址，如果有，就查出对应硬件地址，如果没有，就在本局域网广播发送一个ARP请求分组，得到ARP响应分组后，将得到的IP地址到硬件地址的映射写入ARP高速缓存</p><h3 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h3><p>在IP地址中增加一个子网号字段使两级的IP变为三级IP地址</p><p>从主机号借用若干位作为子网号</p><p>从其他网络发送给本单位某个主机的IP数据包，先找到本单位网络上的路由器，然后此路由器在收到IP数据报后，再按目的网络号和子网号找到目的子网最后将IP数据包交付目的主机</p><p>使用子网掩码可以找出IP地址中的子网部分</p><ol><li>子网掩码长度32位</li><li>子网掩码左边部分一串1，对应网络号和子网号</li><li>子网掩码右边部分一串0，对应于主机号</li></ol><p>注：根据互联网标准协议，子网号不能全0或全1，但随着无份类域间路由选择CIDR的广泛使用，现在全0或全1的子网号也可以使用</p><p>子网划分增加类灵活性但也减少了主机数</p><h4 id="无分类域间路由选择CIDR"><a href="#无分类域间路由选择CIDR" class="headerlink" title="无分类域间路由选择CIDR"></a>无分类域间路由选择CIDR</h4><p>使用各种长度的网络前缀来代替分类地址中的网络号和子网号</p><p>IP地址从三级编址又回到了两级编址</p><p>CIDR使用斜线记法，又称为CIDR记法，在IP地址后加上一个斜线，然后写上网络前缀所占位数</p><p>CIDR把网络前缀都相同的连续IP地址组成CIDR地址块</p><p>路由聚合：</p><ol><li>一个CIDR地址块可以表示很多地址，这种地址的聚合常称为路由聚合，它使路由表中的一个项目可以表示很多个原来传统分类地址的路由</li><li>路由聚合有利于减少路由器之间的路由选择信息交换，从而提高了整个互联网的性能</li><li>路由聚合也成为构成超网</li></ol><p>最长前缀匹配：使用CIDR时路由表中，在查找路由表时可能会得到不止一个匹配结果，应当从匹配结果中选择具有最长网络前缀的路由这种方式称为，最长前缀匹配</p><h3 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h3><p>为了更有效的转发IP数据报和提高交付成功的机会，在网际层使用ICMP，ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告</p><h3 id="网际组管理协议IGMP"><a href="#网际组管理协议IGMP" class="headerlink" title="网际组管理协议IGMP"></a>网际组管理协议IGMP</h3><p>作用于多播中，多播数据包也是尽最大努力交付，不保证一定能够交付多播组内的所有成员，对多播数据报不产生ICMP差错报是否有主机（严格讲，是主机上某个进程）参加或退出了莫格多播组</p><p>IGMP协议是让连接在本地局域网上的多播路由器知道本局域网上shi</p><h3 id="内部网关协议IGP"><a href="#内部网关协议IGP" class="headerlink" title="内部网关协议IGP"></a>内部网关协议IGP</h3><h4 id="路由信息协议RIP"><a href="#路由信息协议RIP" class="headerlink" title="路由信息协议RIP"></a>路由信息协议RIP</h4><p>是一种分布式，基于距离向量的路由选择协议</p><p>RIP要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录</p><p>RIP允许一条路径最多只能包含15个路由器，距离最大值为16即相当于不可达</p><p>RIP不能在两个网络之间同时使用多条路由<br>特点：</p><ol><li>仅和相邻路由器交换信息</li><li>交换的信息是当前本路由器所知道的全部信息</li><li>按固定的时间间隔交换</li></ol><p>存在问题：当网络出现故障时，要经过比较长的时间才能将此信息传到所有路由器<br>优点：实现简单，开销小</p><p>缺点：</p><ol><li>限制了网络的规模</li><li>路由器之间交换的路由信息是路由器中完整的路由表，因而随着网络规模的扩大，开销也就增加</li><li>坏消息传得慢，使更新过程的收敛时间 过长</li></ol><h4 id="内部网关协议OSPF"><a href="#内部网关协议OSPF" class="headerlink" title="内部网关协议OSPF"></a>内部网关协议OSPF</h4><p>开放最短路径优先<br>OSPF不用UDP而是直接用IP数据报传送</p><p>OSPF规定每隔一段时间，要刷新一次数据库中的链路状态</p><p>当互联网规模很大时，OSPF协议要比距离向量协议RIP好的多</p><h3 id="外部网关协议EGP"><a href="#外部网关协议EGP" class="headerlink" title="外部网关协议EGP"></a>外部网关协议EGP</h3><h4 id="边界网关协议BGP"><a href="#边界网关协议BGP" class="headerlink" title="边界网关协议BGP"></a>边界网关协议BGP</h4><p>力求寻找一条能够达到目的网络且比较好的路由，并非要寻找一条最佳路由</p><p>BGP支持CIDR，在BGP刚刚运行时，BGP的邻站时交换整个BGP路由表，但以后只需要在发生变化时更新有变化的部分。这样做对节省网络带宽和减少路由器开销都有好处</p><h4 id="虚拟专用网VPN"><a href="#虚拟专用网VPN" class="headerlink" title="虚拟专用网VPN"></a>虚拟专用网VPN</h4><p>在RFC1918指明了一些专用地址。专用地址只能用作本地地址而不能用作全球地址。在互联网中的所有路由器，对目的地址是专用地址的数据报一律不进行转发</p><p>三个专用地址块：</p><ol><li>10.0.0.0到10.255.255.255</li><li>172.16.0.0到172.31.255.255</li><li>192.168.0.0到192.168.255.255</li></ol><p>采用这样的专用IP地址的互联网络称为专用互联网或本地互联网，简单些叫专用网</p><p>因为这些专用地址尽在本机构内部使用，专用IP地址也叫做可重用地址</p><p>远程接入VPN可以满足外部流动员工访问公司网络需求，专用的VPN软件可以在员工PC机和公司的主机之间建立VPN隧道</p><h3 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h3><p>在专用网连接到互联网的路由器上安装NAT软件。装有NAT软件的路由器叫NAT路由器，他<br><font color = 'red'><br>至少有一个有效的外部全球IP地址。<br></font><br>所有使用本地地址的主机在和外界通信时，都要在NAT路由器上<br><font color = 'red'><br>将其本地地址转换成全球IP地址，才能和互联网互联<br></font></p><p>为了更加有效的利用NAT路由器上的全球IP地址，现在常用的NAT转换表把运输层端口号也利用上。这样，就可以使多个拥有本地地址的主机，共用一个NAT路由器的全球IP地址。使用端口号NAT叫做网络地址与端口号转换NAPT</p><h3 id="多协议标记交换MPLS"><a href="#多协议标记交换MPLS" class="headerlink" title="多协议标记交换MPLS"></a>多协议标记交换MPLS</h3><p>为每个分组携带一个整数标记，当分组达到交换机时，交换机读取分组标记，并用标记值来检索分组转发表。</p><p>MPLS并没有取代IP，而是作为一种IP增强技术。</p><p>特点：</p><ol><li>支持面向连接的服务质量。</li><li>支持流量工程，平衡网络负载。</li><li>有效地支持虚拟专用网VPN</li></ol><p>原理：<br>在MPLS入口处，给每一个IP数据报打上固定长度标记，然后对打上标记的IP数据包用硬件进行转发。<br>采用硬件技术对打上标记的IP数据报进行转发就成为标记交换。</p><p>交换也表示在转发时不再上升到第三层查找转发表，而是而是根据标记在第二层（链路层）用硬件进行转发</p><p>支持MPLS技术的标记交换路由器LSR</p><p>LSR同时具有标记交换和路由选择两种功能，标记交换功能是为了快速转发，<br><font color = 'red'><br>但在这之前LSR需要使用路由选择功能构造转发表<br></font></p><p>工作过程：</p><ol><li>MPLS域中的各LSR使用专门的标记分配协议LDP交换报文，并找出标记交换路径LSP。各LSR根据这些路径构造出分组转发表。</li><li>分组进入MPLS域时，MPLS入口节点把分组打上标记，并按照转发表将分组转发给下一个LSR。给IP数据报打标记的过程叫做分类</li></ol><p>转发等价类就是路由器按照同样方式对待分组的集合</p><p>按照同样方式对待表示：从同样接口转发到同样下一跳地址，并且具有同样服务类别和同样丢弃优先级等</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
