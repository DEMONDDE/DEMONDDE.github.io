<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java三目运算符</title>
      <link href="/2020/09/07/java-san-mu-yun-suan-fu/"/>
      <url>/2020/09/07/java-san-mu-yun-suan-fu/</url>
      
        <content type="html"><![CDATA[<p>当三目运算符进行嵌套时是右结合</p><p>在执行的时候是从左到右执行</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java运算符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于在springMvc使用servlet问题</title>
      <link href="/2020/09/07/guan-yu-zai-springmvc-shi-yong-servlet-wen-ti/"/>
      <url>/2020/09/07/guan-yu-zai-springmvc-shi-yong-servlet-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>在springmvc中可以使用servlet，因为springmvc的前端控制器就是一个servlet，一般情况是对所有请求进行拦截，但由于我们又配置了一个servlet<br>，当我们输入这个servlet的url时，tomcat会进行匹配，而新配置的servlet的url更加匹配，所以会调用这个servlet，而不是调用前端控制器。</p>]]></content>
      
      
      <categories>
          
          <category> Web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用层</title>
      <link href="/2020/09/07/ying-yong-ceng/"/>
      <url>/2020/09/07/ying-yong-ceng/</url>
      
        <content type="html"><![CDATA[<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h3><p>DNS系统采用UDP传输</p><p>互联网采用层次结构的命名数作为主机的名字，并使用分布式的域名系统DNS</p><p>名字到IP地址的解析是由若干个域名服务器程序完成的。域名服务器程序在专设的节点上运行，运行该程序的机器称为域名服务器。</p><p>域名的结构由标号序列组成，各标号之间用点隔开：<br>。。。。 . 三级域名.二级域名.顶级域名</p><p>域名只是个逻辑概念，并不代表计算机所在物理地点</p><p>域名只是有助于记忆</p><p>域名中的点和IP地址的点无对应关系</p><p>基础结构域名：这种顶级域名只有一个，即arpa。用于反向域名接卸，因此又称为反向域名</p><p>域名服务器：</p><ol><li>根域名服务器：<br><br>最高层次的域名服务器，所有的根域名，不管哪一个本地域名服务器，若要对互联网任何一个域名进行解析，只要自己无法解析，就首先求助于根域名服务器，互联网上共有13个不同IP地址的根域名服务器（是13套装置，不是13个机器），它们的名字时一个英文字母命名，从a一直到m</li></ol><p>根域名服务器并不直接把域名直接转换成IP地址。使用迭代查询时，根域名服务器把下一步应当找的顶级域名服务器IP地址告诉本地域名服务器<br>2. 顶级域名服务器：<br><br>3. 负责管理在顶级域名服务器注册的所有二级域名。<br>3. 权限域名服务器：<br><br>负责一个区的域名服务器。当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的DNS客户，下一步应当找哪一个权限域名服务器<br>4. 本地域名服务器（默认域名服务器）</p><h4 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h4><ol><li>主机向本地域名服务器的查询一般都是采用递归查询。如果本机所查询的本地域名服务器不知道被查询域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其他根域名服务器继续发出查询请求报文。</li><li>本地域名服务器向根域名服务器的查询通常是采用迭代查询。当根域名服务器收到本地域名服务器的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地域名服务器：你下一步应当向哪一个域名服务器进行查询。然后让本地域名服务器进行后续查询。</li></ol><h3 id="文件传送协议FTP"><a href="#文件传送协议FTP" class="headerlink" title="文件传送协议FTP"></a>文件传送协议FTP</h3><p>FTP使用客户服务器方式。一个FTP服务器进程可以同时为多个客户进程提供服务，FTP的服务器进程由两大部分组成：一个主进程，负责接受新的请求；另外有若干个从属进程，负责处理单个请求。</p><p>默认端口为21</p><p>两个链接：<br></p><ul><li>控制连接在整个会话期间一直保持打开，FTP 客户发出的传送请求通过控制连接发送给服务器端的控制进程，但控制连接不用来传送文件。</li><li>实际用于传输文件的是“数据连接”。服务器端的控制进程在接收到 FTP 客户发送来的文件传输请求后就创建“数据传送进程”和“数据连接”，用来连接客户端和服务器端的数据传送进程。</li><li>数据传送进程实际完成文件的传送，在传送完毕后关闭“数据传送连接”并结束运行。</li></ul><p>两个端口:<br></p><ul><li>当客户进程向服务器进程发出建立连接请求时，要寻找连接服务器进程的熟知端口 (21)，同时还要告诉服务器进程自己的另一个端口号码，用于建立数据传送连接。</li><li>接着，服务器进程用自己传送数据的熟知端口 (20) 与客户进程所提供的端口号码建立数据传送连接。</li><li>由于 FTP 使用了两个不同的端口号，所以数据连接与控制连接不会发生混乱。</li></ul><p>两个不同端口号的好处：使休矣更加简单个更容易实现。在传输文件时还可以利用控制连接（例如，客户端发送请求终止传输）。</p><p>NFS采用另一种思路：</p><ul><li>NFS 允许应用进程打开一个远地文件，并能在该文件的某一个特定的位置上开始读写数据。</li><li>NFS 可使用户只复制一个大文件中的一个很小的片段，而不需要复制整个大文件。</li><li>例如，计算机 A 的 NFS 客户软件，把要添加的数据和在文件后面写数据的请求一起发送到远地的计算机 B 的 NFS 服务器。NFS * 服务器更新文件后返回应答信息。<br>NFS 在网络上传送的只是少量的修改数据。 </li></ul><h3 id="简单文件传送协议TFTP"><a href="#简单文件传送协议TFTP" class="headerlink" title="简单文件传送协议TFTP"></a>简单文件传送协议TFTP</h3><p>端口为69</p><p>是一个很小且易于实现的文件传送协议。</p><p>TFTP使用客户服务器方式和UDP数据报，一次TFTP需要由自己的差错改正措施</p><p>TFTP只支持文件传输而不支持交互</p><p>特点：</p><ol><li>每次传送的数据 PDU 中有 512 字节的数据，但最后一次可不足 512 字节。</li><li>数据 PDU 也称为文件块 (block)，每个块按序编号，从 1 开始。</li><li>支持 ASCII 码或二进制传送。</li><li>可对文件进行读或写。</li><li>使用很简单的首部</li></ol><ul><li>发送完一个文件块后就等待对方的确认，确认时应指明所确认的块编号。</li><li>发完数据后在规定时间内收不到确认就要重发数据 PDU。</li><li>发送确认 PDU 的一方若在规定时间内收不到下一个文件块，也要重发确认 PDU。这样就可保证文件的传送不致因某一个数据报的丢失而告失败。 </li></ul><p>当文件长度恰好为512字节的整数倍，则在文件传送完毕后，还必须在最后发送一个只含首部而无数据的数据PDU。</p><p>若文件长度不是512字节的整数倍，则最后传送数据PDU的数据字段一定不满512字节，这正好可以作为文件结束标志</p><h3 id="远程终端协议TELNET"><a href="#远程终端协议TELNET" class="headerlink" title="远程终端协议TELNET"></a>远程终端协议TELNET</h3><p>用户用TELNET就可在其所在地通过TCP连接注册（登陆）到远地的另一个主机上（使用主机名或IP地址）</p><p>客户服务器方式</p><ul><li><p>和FTP情况相似，服务器主进程等待新的请求，并产生丛书进程来处理每一个连接</p></li><li><p>客户软件把用户的击键和命令转换成 NVT 格式，并送交服务器。<br>服务器软件把收到的数据和命令，从 NVT 格式转换成远地系统所需的格式。</p></li><li><p>向用户返回数据时，服务器把远地系统的格式转换为 NVT 格式，本地客户再从 NVT 格式转换到本地系统所需的格式。 </p></li></ul><h3 id="万维网"><a href="#万维网" class="headerlink" title="万维网"></a>万维网</h3><p>万维网用链接的方法能非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息。</p><ul><li>万维网是分布式超媒体 (hypermedia) 系统，它是超文本 (hypertext) 系统的扩充。</li><li>一个超文本由多个信息源链接成。利用一个链接可使用户找到另一个文档。这些文档可以位于世界上任何一个接在互联网上的超文本系统中。超文本是万维网的基础。</li><li>超媒体与超文本的区别是文档内容不同。超文本文档仅包含文本信<br>息，而超媒体文档还包含其他表示方式的信息，如图形、图像、声<br>音、动画，甚至活动视频图像。</li></ul><p>万维网已客户服务器方式工作</p><p>浏览器是客户端，万维网文档所驻留的计算机则运行服务器程序，一次这个计算机也称为万维网服务器</p><h4 id="统一资源定位符URL"><a href="#统一资源定位符URL" class="headerlink" title="统一资源定位符URL"></a>统一资源定位符URL</h4><p>标志分布整个互联网上的万维网文档</p><p>形式为：&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</p><p>浏览器为了方便用户输入url时可以不写http://和www<br>对大写和小写没要求</p><h4 id="超文本传输协议HTTP"><a href="#超文本传输协议HTTP" class="headerlink" title="超文本传输协议HTTP"></a>超文本传输协议HTTP</h4><p>使用TCP进行可靠传输，是面向事物</p><p>万维网客户端和服务器交互</p><p>特点：</p><ol><li>使用了面向连接的TCP作为运输层协议，保证了数据的可靠传输</li><li>无连接的，</li><li>面向事务</li><li>HTTP1.0是无状态的</li></ol><p>HTTP1.1使用了持续连接，万维网在发送响应后仍然在一段时间内保持这条链接，使同一个客户和该服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文</p><p>持续链接的两种工作方式：<br>非流水线方式：客户在收到前一个响应后才能发出下一个请求。这比非持续连接的两倍RTT的开销节省了TCP连接所需的一个RTT时间。但服务器在发送完一个对象后，其TCP连接就处于空闲状态，浪费了服务器资源。</p><p>流水线方式：客户在收到HTTP的响应报文之前就能够直接发送新的请求报文。一个接一个的请求报文到达服务器后，服务器就可连续发回响应报文。使用流水线方式时，客户访问所有的对象只需花费一个RTT时间，使TCP连接中的空闲时间减少，提高了下载文档效率。</p><p>代理服务器（万维网高速缓存）：<br>代表浏览器发出的HTTP请求。</p><p>万维网高速缓存将最近的一些请求和响应暂存在本地磁盘。当与暂时存放的请求相同的新请求到达时，万维网高速缓存就把暂存的响应发送出去，而不需要按URL的地址再去互联网访问该资源</p><h3 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h3><p><img src="6EDB21168F474BA5AE181C395D491604" alt="image"></p><p>用户代理UA：用户代理就是用户与电子邮件系统的接口，是电子邮件客户端软件。</p><p>用户代理功能：撰写，显示，处理和通信</p><p>用户和电子邮件的接口又称为电子邮件客户端软件</p><p>邮件服务器的功能是发送和接受邮件，同时还要向发信人报告邮件传送情况</p><p>邮件服务器按照客户服务器方式工作。邮件服务器需要使用发送和读取两个不同的协议</p><p>邮件服务器（邮件传输代理）：<br><br>功能：发送和接受邮件同时还要向发信人报告邮件传输情况<br><br>按照客户服务器方式工作，发送和读取时使用SMTP和POP3</p><p>一个邮件服务器既可以作为客户，也可以作为服务器</p><h4 id="简单邮件发送协议SMTP"><a href="#简单邮件发送协议SMTP" class="headerlink" title="简单邮件发送协议SMTP"></a>简单邮件发送协议SMTP</h4><p>使用TCP连接，使用客户服务器方式，是一个基于文本的协议，在客户和服务器之间采用命令-响应方式</p><p>三个阶段：<br></p><ol><li>连接建立：<br><br>连接是在发送主机的SMTP客户和接收主机的SMTP服务器之间建立的。SMTP不使用中间的邮件服务器</li><li>邮件传输</li><li>连接释放</li></ol><p>缺点：</p><ul><li>SMTP 不能传送可执行文件或其他的二进制对象。</li><li>SMTP 限于传送 7 位的 ASCII 码。许多其他非英语国家的文字（如中文、俄文，甚至带重音符号的法文或德文）就无法传送。</li><li>SMTP 服务器会拒绝超过一定长度的邮件。</li><li>某些 SMTP 的实现并没有完全按照 [RFC 821] 的 SMTP 标准。 </li></ul><h4 id="邮局协议POP3"><a href="#邮局协议POP3" class="headerlink" title="邮局协议POP3"></a>邮局协议POP3</h4><p>使用TCP连接，使用客户服务器方式，支持用户鉴别。服务器删除被用户读取了的邮件</p><h4 id="网际报文存取协议IMAP"><a href="#网际报文存取协议IMAP" class="headerlink" title="网际报文存取协议IMAP"></a>网际报文存取协议IMAP</h4><p>使用客户服务器方式，基于TCP通信，是一个联机协议</p><p>特点：</p><ul><li>连接后只下载邮件首部（部分下载）。</li><li>用户直接在IMAP服务器上创建和管理文件夹。</li><li>用户可以搜索邮件内容。</li><li>用户可以在不同的地方使用不同的计算机随时上网阅读和处理自己的邮件。</li><li>允许收信人只读取邮件中的某一个部分。</li></ul><p>缺点：要想查阅邮件，必须先联网。</p><p>IMAP和POP3比较：<br><img src="E0EF0A664717491FBC474170A3C74360" alt="image"></p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>邮件读取协议 POP 或 IMAP 与邮件传送协议 SMTP 完全不同。<br>发信人的用户代理向源邮件服务器发送邮件，以及源邮件服务器向目的邮件服务器发送邮件，都是使用 SMTP 协议。</li><li>而 POP 协议或 IMAP 协议则是用户从目的邮件服务器上读取邮件所使用的协议。 </li></ul><h4 id="基于万维网的电子邮件"><a href="#基于万维网的电子邮件" class="headerlink" title="基于万维网的电子邮件"></a>基于万维网的电子邮件</h4><p>UA的缺点：必须在计算机中安装用户代理软件。<br>但可能不能安装或不允许安装。<br>因此，不方便收发邮件。</p><p>万维网电子邮件的优点：<br>不需要在计算机中再安装用户代理软件。<br>计算机能联网，就能非常方便地收发电子邮件。<br>电子邮件界面非常友好。</p><p><img src="3894352928ED496AA9B26380D9BBDE98" alt="image"></p><h5 id="通用互联网邮件扩充MIME"><a href="#通用互联网邮件扩充MIME" class="headerlink" title="通用互联网邮件扩充MIME"></a>通用互联网邮件扩充MIME</h5><p>通用互联网邮件扩充 MIME 并没有改动 SMTP 或取代它。<br>MIME 的意图是继续使用目前的 [RFC 822] 格式，但增加了邮件主体的结构，并定义了传送非 ASCII 码的编码规则。</p><p><img src="89DA73EB79E84BC387B3DE071D0E949B" alt="image"></p><h3 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h3><p>使用客户服务器方式，采用请求应对方式工作</p><p>基于UDP，DCHP服务器运行67端口，DCHP客户端运行68端口</p><p>互联网广泛使用DHCP提供了即插即用联网机制<br>这种机制允许一台计算机加入新的网络和获取IP地址，而不用手工配置。</p><p>DHCP给运行服务器软件、且位置固定的计算机指派一个永久地址，给运行客户端软件的计算机分配一个临时地址。</p><ul><li>在协议软件中，给协议参数赋值的动作叫做协议配置。</li><li>一个协议软件在使用之前必须是已正确配置的。</li><li>连接到互联网的计算机的协议软件需要配置的参数包括：</li></ul><ol><li>IP 地址</li><li>子网掩码</li><li>默认路由器的 IP 地址</li><li>域名服务器的 IP 地址</li></ol><ul><li>需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送发现报文<br>（DHCPDISCOVER），这时该主机就成为 DHCP 客户。</li><li>本地网络上所有主机都能收到此广播报文，但只有DHCP 服务器才回答此广播报文。</li><li>DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池 (address pool) 中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文（DHCPOFFER）。 </li></ul><p>DCHP中继代理</p><ul><li>并不是每个网络上都有DHCP服务器，这样会使DHCP服务器的数量太多。现在是每一个网络至少有一个 DHCP 中继代理，它配置了 DHCP 服务器的 IP 地址信息。</li><li>当 DHCP 中继代理收到主机发送的发现报文后，就以单播方式向 DHCP 服务器转发此报文，并等待其回答。收到 DHCP 服务器回答的提供报文后，DHCP 中继代理再将此提供报文发回给主机。</li></ul><p>租用期：</p><ul><li>DHCP 服务器分配给 DHCP 客户的 IP 地址的临时的，因此 DHCP 客户只能在一段有限的时间内使用这个分配到的 IP 地址。DHCP 协议称这段时间为租用期。 </li><li>租用期的数值应由 DHCP 服务器自己决定。</li><li>DHCP 客户也可在自己发送的报文中（例如，发现报文）提出对租用期的要求</li></ul><h4 id="简单网络管理协议SNMP"><a href="#简单网络管理协议SNMP" class="headerlink" title="简单网络管理协议SNMP"></a>简单网络管理协议SNMP</h4><p>按照客户服务器方式，管理程序运行SNMP客户程序，向某个代理程序发出请求（或执行指令）,代理程序运行SNMP服务器程序，返回响应</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运输层</title>
      <link href="/2020/09/07/yun-shu-ceng/"/>
      <url>/2020/09/07/yun-shu-ceng/</url>
      
        <content type="html"><![CDATA[<h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><p>为进程提供端到端的逻辑通信</p><p>端口用一个16位端口号进行标识</p><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ol><li>无连接协议，提供无连接服务</li><li>其传送的运输协议数据单元TPDU时UDP报文或用户数据报</li><li>支持单播，多播，广播</li><li>不提供可靠交付</li><li>简单适用于很多应用</li></ol><p>UDP是面向报文的，没有拥塞控制，支持一对一，一对多，多对一，和多对多，UDP首部开销小，伪首部是为了校验</p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><ol><li>面向连接协议，提供面向连接服务</li><li>其传送的运输协议数据单元TPDU时TCP报文</li><li>支持点对点单播，不支持多播，广播</li><li>提供可靠服务</li><li>复杂用于大多数应用</li><li>提供全双工通信</li></ol><p>面向流：<br>TCP不保证接收放所收到的数据块和发送方应用程序所发出的数据库具有对应大小的关系。<br><br>但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样</p><p>注意：</p><ol><li>TCP 连接是一条虚连接而不是一条真正的物理连接。</li><li>TCP 对应用进程一次把多长的报文发送到 TCP 的缓存中是不关心的。</li><li>TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）。</li><li>TCP 可把太长的数据块划分短一些再传送。</li><li>TCP 也可等待积累有足够多的字节后再构成报文段发送出去。 </li></ol><p>TCP可靠传输的实现:具体实现,重传时间的选择,选择确认</p><p>TCP头部最小长度时20字节<br>头部：</p><ol><li>确认号：4字节，是期望收到对方下一个报文段的数据的第一个字节的序号</li><li>确认ACK：只有当ACK=1时确认字号字段才有效，ACK=0，确认好无效</li><li>PSH：当PSH=1，TCP应尽快交付接受应用进程，而不是等到缓存填满后在向上交付</li><li>SYN：同步SYN=1表示这是一个连接请求或连接接受报文</li><li>FIN：终止FIN用来释放一个连接，FIN=1表明此报文的的发送端的数据已发送完毕，并要求释放运输连接</li><li>窗口字段：2字节，让对方设置发送窗口的依据，单位为字节</li></ol><p>TCP连接的端点叫套接字（端口号拼接到IP地址即构成了套接字）</p><p>TCP可靠通信的体现：</p><ol><li>TCP连接的每一段都必须设有两个窗口，一个发送窗口，一个接受窗口</li><li>TCP的可靠传输机制用字节的序号进行控制。TCP所有的确认都是基于序号而不是基于报文段</li><li>TCP两端的四个窗口经常处于动态变化之中</li><li>TCP连接的往返时间RTT也不是固定不变的。需要使用特定的算法估算较为合理的重传时间<h4 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h4></li><li>停止等等：发送方只发送一个分组，收到确认就在发送</li><li>编码：每个分组都要编码</li><li>自动重传请求：发送方为每个发送的分组设置一个超级计时器，若超时，发送方就会自动重传分组<br>正常情况：<br><br>发送方先发送分组，发完就暂停发送，当接收方接收后，发送确认信息ACK，发送方在接受确认信息后，就在发送下个分组，发送方接收后，继续发送下一分组<br><br>但由于网络质量不可保证，所以会采用自动重传请求ARQ</li></ol><p>并且停止等待协议传输效率太低，发送方可以采用流水线传输</p><p>流水线传输：发送方可以连续发送多个分组，不必每发完一个分组就等待确认，<br>注意：在发送完一个分组后，必须暂时保留已发送的分组的副本，以备重发。分组和确认分组都必须进行编号。超市计时器的重传时间应当比数据在分组传输的平均往返时间更长一些</p><h4 id="自动重传请求ARQ"><a href="#自动重传请求ARQ" class="headerlink" title="自动重传请求ARQ"></a>自动重传请求ARQ</h4><p>错误情况：<br></p><ol><li>分组错误：当发送方发送分组出错时，接收方会丢弃，并不会发送确认信息，此时发送方会启动超级即使来等待ACK<br>当超时会重新发送该分组。</li><li>分组丢失：当分组在发送时丢失了，接收方也不会发送确认信息，接收方会启动超级计时器，超时后会重新发送该分组</li><li>确认丢失：当接收方接受分组后，发送确认信息，当确认信息丢失了，发送方也会启动计时器，超时后会重新发送分组</li><li>确认迟到：当接收方确认信息，传输太慢导致发送方启动了超时重传，重新发送分组，接收方收到重新发送的分组后发送确认信息，接收方继续发送下一个分组，当此时第一个确认信息到达后，发送方会接受确认信息，并会发现重复，会把重复的确认信息丢弃。</li></ol><p>通常发送方最终总是可以接受到所有分组的确认，如果发送方不断重传分组，但总是收不到确认，就说明通信线路太差，不能进行通信。<br>使用确认和重传机制，我们就可以在不可靠的传输网络上实现可靠通信。<br>重传的请求是自动进行的，接收方不需要请求发送方重传某个出错的分组</p><h4 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h4><p>连续ARQ协议传输控制通过滑动窗口协议</p><p>发送方维持一个发送窗口，收到确认后发送窗口向前滑动</p><p>连续ARQ协议采用回退N重传<br>确认机制采用单个确认和累计确认</p><p>Go-back-N（回退N）：如果发送方发送了前5个分组，而中间的第三个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次。<br><br>这就叫回退N，表示需要再退回来重传已发送的N个分组。<br><br>可见当通信线路质量不好使，连续ARQ西医会带来负面影响</p><p>累计确认：接收方一般采用累计确认的方式。即不必对收到的分组逐个发送确认而是对按序到达的最后一个分组发送确认，这样就表示：到这个分组位置的所有分组都已正确收到了。<br><br>优点：容易实现，即使确认丢失也不必重传。<br><br>缺点：不能向发送方反映出接收方已经正确收到所有分组的信息。</p><h4 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h4><p>发送窗口的意义：位于发送窗口内的分组都可以连续发送出去，而不需要等待对方的确认</p><p>发送缓存暂时存放：</p><ol><li>发送应用程序传送给发送放TCP准备发送的数据</li><li>TCP已发送出但尚未收到的确认的数据</li></ol><p>接受缓存赞数存放：</p><ol><li>按序到达的，但尚未被接受应用程序读取的数据</li><li>不按序到达的数据</li></ol><p>发送窗口通常只是发送缓存的一部分，当发送窗口里的序号都已发送完，但还没收到确认，发送方会暂停</p><p>注意：</p><ol><li>发送窗口不总是和接收窗口一样的（因为有一段时间的滞后）</li><li>TCP标准没有规定对不按序到达的数据应如何处理通常是先临时存放在接受窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程</li><li>TCP要求接收方必须有累计确认的功能，这样可以减少传输开销</li></ol><p>接收方发送确认：<br><br>接收方可以再合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上<br><br>注意：<br></p><ol><li>接收方不应过分推迟发送确认，否则会导致发送方不必要的重传，反而浪费了网络资源</li><li>捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据</li></ol><p>TCP通过可变滑动窗口实现流量控制</p><p>可能发生的死锁：</p><ol><li>B 向 A 发送了零窗口的报文段后不久，B 的接收缓存又有了一些存储空间。于是 B 向 A 发送了 rwnd = 400 的报文段。</li><li>但这个报文段在传送过程中丢失了。A 一直等待收到 B 发送的非零窗口的通知，而 B 也一直等待 A 发送的数据。</li><li>如果没有其他措施，这种互相等待的死锁局面将一直延续下去。</li><li>为了解决这个问题，TCP 为每一个连接设有一个持续计时器 (persistence timer)。</li></ol><p>当接收到的字节流序号不连续时可以通过使用选择确认SACK来传输缺少的数据</p><h4 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h4><p>拥塞控制与流量控制区别：<br><br>拥塞控制：防止过多的数据注入到网络中，使网络中的路由器或链路不致过载。</p><p>是一个全局性的过程，涉及到与降低网络传输性能有关的所有因素</p><p>流量控制：抑制发送端发送数据的速率，已使接收端来得及接收</p><p>是点对点通信量的控制，是端到端的问题</p><p>开环控制：设计时事先考虑周全，力争避免发生拥塞<br><br>闭环控制：根据网络当前的运行状态采取相应控制措施，在发生拥塞后，采取措施进行控制，消除拥塞</p><h5 id="拥塞控制算法"><a href="#拥塞控制算法" class="headerlink" title="拥塞控制算法"></a>拥塞控制算法</h5><p>TCP可靠传输的实现:具体实现,重传时间的选择,选择确认</p><p>拥塞窗口cwnd，慢开始门限ssthresh</p><ol><li>慢开始：<br><br>目的：用来确定网络的负载能力或拥塞程度<br><br>算法：由小到大逐渐增大拥塞窗口，每收到一个确认cwnd就加1，一个传输轮次后cwnd加倍</li></ol><p>慢开始门限 ssthresh 的用法如下：</p><ul><li>当 cwnd &lt; ssthresh 时，使用慢开始算法。</li><li>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</li><li>当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。</li></ul><ol start="2"><li>拥塞避免：<br><br>让拥塞窗口cwnd缓慢增大，没经过一个传输轮次，cwnd+1<br></li></ol><ul><li>ssthresh = max (cwnd/2，2)</li><li>cwnd = 1</li><li>执行慢开始算法</li></ul><p>注：无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（重传定时器超时）。<br>，<br>3. 快重传：<br><br>当发送方一连收到3个对同一个报文段的重复确认，发送方改为执行快重传和快恢复<br>4. 快恢复：<br><br>当发送端收到连续三个重复的确认时，由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，而是执行快恢复算法 FR (Fast Recovery) 算法：</p><ul><li>慢开始门限 ssthresh = 当前拥塞窗口 cwnd / 2 </li><li>新拥塞窗口 cwnd = 慢开始门限 ssthresh ；</li><li>开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。 </li></ul><p>TCP拥塞控制方法</p><ol><li>TCP采用基于窗口的方法进行拥塞控制。该方法属于闭环控制</li><li>TCP发送方维持一个拥塞控制窗口cwnd</li><li>发送到利用拥塞窗口根据网络的拥塞情况调整发送的数据量。</li><li>发送窗口大小不仅取决于接收方窗口，还取决于，网络的拥塞状况，所以真正的发送窗口值为：Min（接受方窗口值，拥塞窗口值）</li></ol><h4 id="TCP建立（三次握手"><a href="#TCP建立（三次握手" class="headerlink" title="TCP建立（三次握手)"></a>TCP建立（三次握手)</h4><ol><li>A 的 TCP 向 B 发出连接请求报文段，其首部中的同步位 SYN = 1，并选择序号 seq = x，表明传送数据时的第一个数据字节的序号是 x。</li><li>B 的 TCP 收到连接请求报文段后，如同意，则发回确认。<br>B 在确认报文段中应使 SYN = 1，使 ACK = 1，其确认号 ack = x + 1，自己选择的序号 seq = y。</li><li>A 收到此报文段后向 B 给出确认，其 ACK = 1，确认号 ack = y + 1。<br>A 的 TCP 通知上层应用进程，连接已经建立,B 的 TCP 收到主机 A 的确认后，也通知其上层应用进程：TCP 连接已经建立</li></ol><h4 id="TCP连接释放-四次挥手"><a href="#TCP连接释放-四次挥手" class="headerlink" title="TCP连接释放(四次挥手)"></a>TCP连接释放(四次挥手)</h4><ol><li>数据传输结束后，通信的双方都可释放连接。<br>现在 A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。<br>A 把连接释放报文段首部的FIN = 1，其序号seq = u，等待 B 的确认。</li><li>B 发出确认，确认号 ack = u+1，而这个报文段自己的序号 seq = v。<br>TCP 服务器进程通知高层应用进程。<br>从 A 到 B 这个方向的连接就释放了，TCP 连接处于半关闭状态。B 若发送数据，A 仍要接收。</li><li>若 B 已经没有要向 A 发送的数据，<br>其应用进程就通知 TCP 释放连接。<br>B向A发送报文段 FIN=1，ACK=1，seq=w，ack=u+1</li><li>A向B发送确认报文段在确认报文段中ACK = 1，确认号 ack = w + 1，自己的序号 seq = u + 1<br>此时A等待2MSL时间最后关闭</li></ol><p>A 必须等待 2MSL 的时间：第一，为了保证 A 发送的最后一个 ACK 报文段能够到达 B。<br>第二，防止 “已失效的连接请求报文段”出现在本连接中。</p><p>保活计时器：用来防止在TCP连接出现长时期的空闲。<br>保活计时器 通常设置为2小时 。若服务器过了2小时还没有收到客户的信息，它就发送探测报文段。若发送了10个探测报文段（每一个相隔75秒）还没有响应，就假定客户出了故障，因而就终止该连接。 </p><h4 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h4><p>【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？</p><p>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p><p>【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</p><p>答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p><p>【问题3】为什么不能用两次握手进行连接？</p><p>答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。</p><pre><code>   现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</code></pre><p>【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？</p><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><p>【问题5】为什么需要三次握手</p><ul><li>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤</li><li>如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认</li></ul><p><font color='red'>个人理解：因为由于网络质量不一定可靠所以，可能接收方发送的同步连接丢失，所以需要发送方发送确认信息，来告诉接收方我已收到</font></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC注解</title>
      <link href="/2020/07/22/springmvc-zhu-jie/"/>
      <url>/2020/07/22/springmvc-zhu-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h2><p>指定访问路径</p><pre><code>path:映射路径value：映射路径，可以省略，可以写多个路径method:指定请求方式params:指定限制请求参数的条件，它支持简单表达式，要求参数的key和value必须和配置的一模一样</code></pre><h2 id="RequeParam"><a href="#RequeParam" class="headerlink" title="@RequeParam"></a>@RequeParam</h2><p>把请求中指定名称的参数给控制器的形参赋值</p><pre><code>value:请求参数的名称required：请求参数中是否必须提供此参数，默认为true，如果不提供将报错defaultValue：默认参数值，如果设置了该值，required=true将失效，自动为false,如果没有传该参数，就使用默认值</code></pre><h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h2><p>获取请求体内容，直接获取请求体全部数据，get方法不适用</p><p>主要用来接收前端传递给后端的json字符串中的数据的(请求体中的数据的)；@RequestBody与@RequestParam()可以同时使用</p><p>当前台传过来的数据类型为 application/json时使用@Requestbody来接收参数</p><pre><code>required：是否必须有请求体，默认为true，get方式会报错</code></pre><h2 id="PathVaribale"><a href="#PathVaribale" class="headerlink" title="@PathVaribale"></a>@PathVaribale</h2><p>用于绑定url中的占位符。例如: 请求url中/delete/{id},这个{id}就是url占位符。<br>url支持占位符是spring3.0之后加入的。是springmvc支持rest风格URL的一个重要标志。</p><pre><code>value:用于指定url占位符名次；required</code></pre><h2 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h2><p>获取请求头</p><p>实际开发不常用</p><pre><code>value：提供消息头required：是否必须有消息头</code></pre><h2 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a>@CookieValue</h2><p>用于指定cookie名称的值传入控制器方法参数</p><pre><code>value:指定cookie名称required：是否必须有此cookie</code></pre><h2 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h2><p>可以修饰方法和参数</p><p>出现方法上，表示当前方法会在控制器的方法执行之前，先执行。它可以修饰没有返回值的方法，通过map接收处理的数据。也可以修饰有返回值的方法，返回值可以作为参数被接收</p><p>出现参数上，获取指定的数据给参数赋值，通过map接收处理的数据，在通过 @ModelAttribute指定参数来获取map的数据。</p><h2 id="SessionAttribute"><a href="#SessionAttribute" class="headerlink" title="@SessionAttribute"></a>@SessionAttribute</h2><p>用于多次执行控制器方法间的参数共享</p><p>能将指定的名称属性通过model存入session里</p><pre><code>value：用于指定存入的属性名称type：用于指定存入的数据类型</code></pre>]]></content>
      
      
      <categories>
          
          <category> Web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring注解</title>
      <link href="/2020/07/22/spring-zhu-jie/"/>
      <url>/2020/07/22/spring-zhu-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h2><p>指定当前类是配置类</p><p>注：当配置类作为AnnotationConfigApplicationContext的参数时可以不用写</p><h2 id="ComponentScan（）"><a href="#ComponentScan（）" class="headerlink" title="@ComponentScan（）"></a>@ComponentScan（）</h2><p>创建容器所要扫描的包<br>    basePackages：包的位置<br>    value：可以填写多个包的位置</p><h2 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h2><p>用于把当前方法的返回值作为bean对象存入spring的ioc容器中。</p><p>name:指定bean的id</p><h2 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h2><p>决定是单例还是多例<br>    singleton：单例<br>    prototype：多例</p><h2 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h2><p>导入其他配置类 </p><h2 id="PropertySource-和-PropertySources"><a href="#PropertySource-和-PropertySources" class="headerlink" title="@PropertySource 和 @PropertySources"></a>@PropertySource 和 @PropertySources</h2><p>导入properties配置文件</p><pre><code>value：文件的名称和路径    关键字：classpath 在类路径下</code></pre><h2 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h2><p>配合@PropertySource 和 @PropertySources使用，读取配置信息</p>]]></content>
      
      
      <categories>
          
          <category> Web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle</title>
      <link href="/2020/07/17/oracle/"/>
      <url>/2020/07/17/oracle/</url>
      
        <content type="html"><![CDATA[<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>和其他数据库不一样，这里的数据库是一个操作系统只有一个库，可以看作Oracle就只有一个大数据库</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>一个Oracle实例有一系列的后台进程和内存结构组成，一个数据库可以有n个实例。其实也是数据库不过是软件上的</p><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><p>用户是在实例下建立的不同实例可以有同名用户。</p><font color='red'>注：表是由用户管理的。</font><h3 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h3><p>对数据库进行了逻辑的划分</p><h2 id="创建表空间"><a href="#创建表空间" class="headerlink" title="创建表空间"></a>创建表空间</h2><pre><code>create tablespace itheima//保存路径datafile &#39;路径&#39;//容量size 100m //容量为100m//内存不够时自动扩展autoextend onnext 10m; //每次扩展10m</code></pre><pre><code>//删除表空间drop tablespace itheima</code></pre><h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><pre><code>create user itheima(用户名)identifie by itheima(密码)//默认表空间default tablespace ithima（表空间名）;</code></pre><pre><code>oracle数据库常用角色connect //连接角色，基本jues 没这个角色将无法使用resource //开发角色dba //超级管理员//给用户授予角色grant dba to itheima</code></pre><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>varchaar 和 varchar2 表示一个字符串 ，更常用varchar2</p><p>number（n）表示一个整数长度为n</p><p>number（m，n）表示一个小数，总长度为m，小数是n整数时m-n</p><p>data 表示日期</p><p>clob大对象 表示大文本数据类型可存4g</p><p>blob 大对象，表示二进制数据可存4g</p><h2 id="表的创建和修改"><a href="#表的创建和修改" class="headerlink" title="表的创建和修改"></a>表的创建和修改</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><pre><code>create table person{    pid number(20),    pname varchar2(10)}</code></pre><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><pre><code>//添加列alter table person add (gender number(1));//修改列类型alter table person modify gender char(1);//修改列名称alter table person rename column gender to sex;</code></pre><h2 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h2><p>Oracle的数据库的增删改必须进行commit</p><p>增和改于MySQL一样<br>但删除有所不同</p><pre><code>//删除全部记录delete from person;//删除表结构drop table person;//先删除表，在创建表。效果等同于删除表中全部记录对于有大量数据的表，采取此方法会更快truncate table person;</code></pre><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>默认从1开始，一次递增，主要用来给主键赋值使用。</p><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>create sequence s_person（名称）；</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>s_person.currval 查看当前索引</p><p>s_person.nextval 获得下一个索引</p><font color='red'>Oracle的查询必须需要表就是from后必须加一个表不能省略。但没有表时可以使用dual作为虚拟表使用。<p>dual只是不全语法的，没实际意义<br></font></p><h2 id="scott用户"><a href="#scott用户" class="headerlink" title="scott用户"></a>scott用户</h2><p>是Oracle自带的用户，用来给用户学习</p><h3 id="解锁scott"><a href="#解锁scott" class="headerlink" title="解锁scott"></a>解锁scott</h3><p>必须有超级管理员</p><p>alter user scott account unlock;</p><h3 id="解锁密码"><a href="#解锁密码" class="headerlink" title="解锁密码"></a>解锁密码</h3><p>alter user scott identified by tiger(可以修改别的密码)</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h3><h4 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h4><pre><code>upper()  //大写lower() //小写</code></pre><h4 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h4><pre><code>round(&#39;&#39;,m) //四舍五入 m表示保留几位，负数为往前保留 如-1为保留10位数。trunc(&#39;&#39;,m)//直接截取，不看后边的数字mod(&#39;&#39;,m) //求余数</code></pre><h4 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h4><pre><code>sysdate-表的日期//距离现在多少天sysdate+1 //明天此刻months_between(sysdate,表的日期)//距离现在几月months_between(sysdate,表的日期)/12 //距离现在几年(sysdate-表的日期)/7 //距离现在几周</code></pre><h4 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h4><pre><code>to_char(sysdate,&#39;yyyy-mm-dd hh:mi:ss&#39;)//日期转字符串to_char(&#39;yyyy-mm-dd hh:mi:ss&#39;,sysdate)//字符串转日期</code></pre><h4 id="通用函数"><a href="#通用函数" class="headerlink" title="通用函数"></a>通用函数</h4><pre><code>nvl(&#39;&#39;,m)//如果值位null则替换位m</code></pre><h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><p>从查找出的结果进行判断</p><pre><code>select    e.ename    case e.ename        when &#39;SMITH&#39; then &#39;曹贼&#39;        when &#39;ALLEN&#39; then &#39;大耳贼&#39;        else &#39;无名&#39;        endfrom     emp e;</code></pre><p><img src="8A35A4F79C0944A18A5E9C7A86D96F4D" alt="image"></p><pre><code>select    e.sal    case     when e.sal &gt; 3000 then &#39;高收入&#39;    when e.sal &gt; 1500 then &#39;中等收入&#39;    else &#39;低收入&#39;    endfromemp e；</code></pre><p><img src="BA4D6D817CAF4493B0F6E08E5EF04E2B" alt="image"></p><h4 id="oracle专用表达式"><a href="#oracle专用表达式" class="headerlink" title="oracle专用表达式"></a>oracle专用表达式</h4><pre><code>select    e.ename    decode( e.ename,         &#39;SMITH&#39; , &#39;曹贼&#39;,         &#39;ALLEN&#39; , &#39;大耳贼&#39;,         &#39;无名&#39;)&quot;别名&quot;from     emp e;</code></pre><h3 id="多行函数"><a href="#多行函数" class="headerlink" title="多行函数"></a>多行函数</h3><pre><code>count()//查询总数sum()//总和max()//最大值min()//最小值avg()//平均</code></pre><h2 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h2><p>分组查询中，出现在group by后面的原始列，才能出现在select后面。没有出现在group by后面的列，想在select后面，必须加上聚合函数</p><p>所有条件都不能使用别名来判断</p><p>group by 列明 //进行分组</p><p>where是过滤分组前的数据，having是过滤分组后的数据</p><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>Oracle专用用法</p><pre><code>select    *form    emp e ,dept dwhere    e.deptno = d.petno(+)</code></pre><p>当哪个表用(+)表示时它的令一个表的数据会全部显示，上边的语句等同于e表和d表进行左连接，e表的数据全部显示</p><h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><p>rownum 是行号，在查询时加上可以显示行号，但进行排序时行号会错乱。</p><p>可以先将查询结果当作子表，在进行输出可以解决</p><pre><code>select     rownum, t.*from    (select        rownum, e.*     from         emp e    order by        e.asl desc    ) t;</code></pre><p>可以使用rownum作为分页查询</p><p>但rownum不能写大于一个正数</p><pre><code> select * from(    select rownum rn, e.* from(        select * from emp order by sal desc    )e where rownum &lt; 11 )where rn &gt; 5 将 rownum起个别名可以实现让rownum大于一个正数</code></pre><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图提供一个查询的窗口，所有数据来源原表，创建视图必须有dba权限</p><pre><code>create table emp as select * from scott.emp;//创建视图create view v_emp as select ename, jb from emp//创建只读视图create view v_emp as select ename, jb from empwith read only;</code></pre><h3 id="视图作用"><a href="#视图作用" class="headerlink" title="视图作用"></a>视图作用</h3><ol><li>屏蔽一些敏感字段</li><li>保证总部和分组数据及时统一。</li></ol><h2 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h2><p>在表的列上构建一个二叉树，大幅度提高查询效率的目的，但是索引会影响增删改效率。</p><h3 id="单列索引"><a href="#单列索引" class="headerlink" title="单列索引"></a>单列索引</h3><p>触发规则，条件必须是索引中的原始值，单行函数，模糊查询，都会影响索引的触发</p><pre><code>create index idx_ename on emp(ename);//会触发单列索引select * from emp where ename = &#39;SCOTT&#39;</code></pre><h3 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h3><p>复合索引中第一列位优先检索列。如果要触发复合索引，必须包含有优先检索列中的原始值</p><pre><code>create index idx_enamejob on emp(ename,job);//会触发复合索引select * from emp where ename = &#39;SCOTT&#39; and job=&#39;xx&#39;//不触发select * from emp where ename = &#39;SCOTT&#39; or job=&#39;xx&#39;//会触发单列索引select * from emp where ename = &#39;SCOTT&#39;</code></pre><h2 id="pl-sql编程语言"><a href="#pl-sql编程语言" class="headerlink" title="pl/sql编程语言"></a>pl/sql编程语言</h2><p>是对sql语言的扩展，使得sql语言具有过程化编程的特性。主要用来编写存储过程和存储函数等</p><h3 id="声明方法"><a href="#声明方法" class="headerlink" title="声明方法"></a>声明方法</h3><pre><code>declare    i number(2) := 10;    s varchar2(10) := &#39;xiaom&#39;;    //引用型变量    ena emp.ename%type;    //记录型变量（存放一行记录）    emprow emp%rowtype;begin    dbms_output.put_line(i);    dbms_output.put_line(s);    //查询语句赋值    select ename into ena from emp where empno = 7788;    select * me into emprow from emp where empno = 7788;end;</code></pre><h3 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h3><pre><code>declare    i number(3) := &amp;ii;begin    if i&lt;18 then        dbms_output.put_line(&#39;未成年&#39;);    elseif i&lt;40 then        dbms_output.put_line(&#39;中年&#39;);    else        dbms_output.put_line(&#39;老年&#39;);    end if;end</code></pre><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><pre><code>//while 循环declare    i number(2) := 1;begin    while i &lt; 11 loop        dbms_output.put_line(i);        i := i+1;    end loop;end;//exit循环declare    i number(2) := 1;begin    loop        exit when i &gt; 10;        dbms_output.put_line(i);        i := i+1;    end loop;end;//for循环declarebegin    for i in 1..10 loop       dbms_output.put_line(i);    end loop;end</code></pre><h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><p>类似Java的集合，可以放多个对象，多行记录</p><pre><code>declare    cursor c1 is select * from emp;    emprow emp%rowtype;begin    open c1;        loop            fetch c1 into emprow;            exit when c1%notfound;            dbms_output.put_line(emprow);        end loop;    close c1;</code></pre><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>存储过程就是提前编译好的一段pl/sql语言，放置在数据库可以直接被调用，一般是固定步骤的业务。</p><pre><code>create [or replace] PROCEDURE 过程名[(参数名 in/out 数据类型)]AS | isbeginend;in和out，凡是涉及into查询语句赋值或者：=赋值操作的参数都必须使用out来修饰，其余都用in。不写默认为inor repalce 代表可以直接修改例如: create or replace procedure pl(eno emp.empno%type)isbegin    update emp set sal = sal+100 where empno = eno;    commit;end;</code></pre><h2 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h2><p>存储过程和存储函数参数都不能带长度</p><p>存储函数的返回值类型不能带长度</p><pre><code>create [or replace] FUNCTION 函数名(参数名  数据类型，参数名  数据类型)return 数据类型AS | is结果变量 数据类型；begin    return（结果变量）end;create or replace function f_yearsal(eno emp%type) return number is    s number(10);begin    select sal*12+nvl(comn,0) into s from emp where empno = eno;    return s;end;</code></pre><h2 id="存储过程和存储函数的区别"><a href="#存储过程和存储函数的区别" class="headerlink" title="存储过程和存储函数的区别"></a>存储过程和存储函数的区别</h2><p>1.存储函数有返回值，而存储过程没有返回值。而如果存储过程想实现返回值，就必须使用out类型参数。即使是存储过程使用了out类型参数，本质也不是真的有了返回值，而是存储过程内部给out类型参数赋值，在执行完毕后直接拿去</p><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>触发器是制定一个规则，在我们做增删改操作时会自动触发，查询不会触发</p><p>触发器有两类，语句级触发器，行级触发器。当包含for each row就是行级触发器</p><h3 id="语句级触发器"><a href="#语句级触发器" class="headerlink" title="语句级触发器"></a>语句级触发器</h3><pre><code>create or replace trigger t1afterinserton persondeclarebegin    dbms_output.put_line(&#39;入职&#39;)end;</code></pre><h3 id="行级触发器"><a href="#行级触发器" class="headerlink" title="行级触发器"></a>行级触发器</h3><pre><code> create or replace trigger t2 before update on emp for each row declare begin    if :old.sal &gt; :new.sal then        raise_application_error(-20001,&#39;错误&#39;)    end fi;end;</code></pre><p>给主键列赋值</p><pre><code>create or replace trigger auidbeforeinserton personfor each rowdaclarebegin    select s_person.nextval into :new.pid from dual;end;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对于路径问题探讨</title>
      <link href="/2020/07/07/dui-yu-lu-jing-wen-ti-tan-tao/"/>
      <url>/2020/07/07/dui-yu-lu-jing-wen-ti-tan-tao/</url>
      
        <content type="html"><![CDATA[<p>在前端书写路径如添加css，js，或servlet等可以使用绝对路径或相对路径。</p><p>相对路径是以本资源文件所在路径为根路径</p><p>注意:</p><p>当我们把jsp，html等页面放在web－inf中我们是无法直接访问的，所以我们一般通过controller等方式转发来访问，在这时如果<br>css，js等文件在web－inf里是无法引入到jsp文件里的，如果放到web－inf外，当使用相对路径是不是以资源文件所在路径为根路径，而是以请求链接controller的路径为根路径<br>如当到us.jsp的controller路径为/con/us<br>那么相对路径的根路径就是/con，</p><p>所以jsp放web－inf里时尽量用绝对路径</p><p>绝对路径以项目为根路径</p><p>注意:<br>在前端中绝对路径的根路径是以服务器为根路径的</p><p>注意2:当在前端使用相对路径时会自动加上项目名</p>]]></content>
      
      
      <categories>
          
          <category> Web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于数据库多表问题</title>
      <link href="/2020/07/07/guan-yu-shu-ju-ku-duo-biao-wen-ti/"/>
      <url>/2020/07/07/guan-yu-shu-ju-ku-duo-biao-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>数据库多表查询可以分为内连接和外连接</p><h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><h3 id="隐式内连接"><a href="#隐式内连接" class="headerlink" title="隐式内连接"></a>隐式内连接</h3><pre><code>如：select     *from    student,departmentwhere    条件</code></pre><p>隐式内连接会将两张表进行笛卡尔乘积，将所有的结果进行显示，可以用where将不符合的条件进行剔除</p><h3 id="显式内连接"><a href="#显式内连接" class="headerlink" title="显式内连接"></a>显式内连接</h3><pre><code>如：select     *from    student [inner] join department on 条件where    条件</code></pre><p>显式内连接也会将两张表进行笛卡尔乘积，但是可以使用on后接条件来进行剔除，而不是使用where</p><h2 id="左连接和右连接"><a href="#左连接和右连接" class="headerlink" title="左连接和右连接"></a>左连接和右连接</h2><p>左连接和右连接很类似</p><pre><code>左连接select     *from    student left [outer] join department on 条件where    条件右连接select     *from    student right [outer] join department on 条件where    条件</code></pre><p>左连接会以左边的表为基准（上边的student表就是左表）与右表的交集进行结合。</p><p>简单来说，会以student表为基准，然后通过on的条件来筛选department，将筛选出来的信息与student相对应的信息进行拼接。然后生成新的表。</p><p>注：如果student中没有对应department的信息<br>则student的信息一样会显示，而对应的department信息会显示空</p><p>右连接和左连接相反，是以department为基准</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx location的root问题</title>
      <link href="/2020/06/13/nginx-location-de-root-wen-ti/"/>
      <url>/2020/06/13/nginx-location-de-root-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p>location root属性会对拦截的路径进行拼接如</p><p>当location拦截路径为 /test/时<br>客户端请求连接为 <a href="http://localhost/test/aa/1.txt" target="_blank" rel="noopener">http://localhost/test/aa/1.txt</a><br>而root 为 /var/ss<br>最终结果为 /var/ss/test/1.txt<br>此时会将/test/之后包括/test/添加到test之后</p><p>当location拦截路径为/时<br>客户端请求连接为 <a href="http://localhost/test/aa/1.txt" target="_blank" rel="noopener">http://localhost/test/aa/1.txt</a><br>root设置为 /var/ss<br>最后结果为/var/ss/test/aa/1.txt<br>此时会将除<a href="http://localhost外所有拼接到root路径后" target="_blank" rel="noopener">http://localhost外所有拼接到root路径后</a></p><p>当按文件名进行匹配时，当页面链接如 href= css/a.css时<br>此时当发送请求时浏览器会自动添加其项目名<br><br><br>该请求链接完整是<font color ='red'> http:/地址/项目名/css/a.css</font><br><br>当root路径为/var/ss或http:localhost/<br><br>此时真实路径为/var/ss/css/a.css<br><br>nginx会将请求除http:/地址/之外的所有添加到root后面<br><br>所以最后结果为 /var/ss/项目名/css/a.css<br><br>这时真实路径下/css/a.css在ss文件夹下，并不在项目名文件夹下，所以浏览器会获取不到，需要在/ss/目录下创建和该项目同名的文件这是才会和最终路径匹配</p>]]></content>
      
      
      <categories>
          
          <category> Web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx使用</title>
      <link href="/2020/06/06/nginx-shi-yong/"/>
      <url>/2020/06/06/nginx-shi-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>访问nginx,但是nginx把请求交给tomcat来做</p><p>然后修改nginx.conf，主要是30-42行</p><pre><code>        location / {            proxy_pass http://127.0.0.1:8111;    }    //location / 表示处理所有请求    //proxy_pass http://127.0.0.1:8111; 表示把请求都交给http://127.0.0.1:8111来处理</code></pre><h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p>css, js之类的都交给nginx来处理，nginx处理不了的，比如jsp 就交给tomcat来处理~</p><p>在locaction下面添加一个新的location:</p><pre><code>        location ~\.(css|js|png)$ {            root C:/Users/X7TI/Downloads/tomcat_8111/webapps/ROOT;            }    //这表示所有的css js png访问都由nginx来做，访问的地址是    //C:/Users/X7TI/Downloads/tomcat_8111/webapps/ROOT    //这里要注意，填写本地地址的时候，要用正斜杠 / 不要用反斜杠 \</code></pre><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>负载均衡的概念就是当访问量很大的时候，一个 Tomcat 吃不消了，这时候就准备多个 Tomcat，由Nginx按照权重来对请求进行分配，从而缓解单独一个Tomcat受到的压力</p><p>首先增加一个upstream ，用来指向这两个tomcat</p><pre><code>  upstream tomcat_8111_8222{    server    127.0.0.1:8111 weight=1;    server    127.0.0.1:8222 weight=2;    }</code></pre><p>然后修改location，反向代理到上述配置。</p><pre><code>        location / {            proxy_pass http://tomcat_8111_8222;    }</code></pre><p>weight表示权重，值越大，被分配到的几率越大</p><h2 id="session共享"><a href="#session共享" class="headerlink" title="session共享"></a>session共享</h2><p>将session信息存到rides中需要取的时候，也从Redis上取。</p>]]></content>
      
      
      <categories>
          
          <category> Web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis</title>
      <link href="/2020/06/05/redis/"/>
      <url>/2020/06/05/redis/</url>
      
        <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ol><li>字符串类型String</li><li>哈希类型 hash：map格式</li><li>列表类型list：linkedlist格式</li><li>集合类型set：</li><li>有序集合类型sortedset</li></ol><h1 id="常用存储操作"><a href="#常用存储操作" class="headerlink" title="常用存储操作"></a>常用存储操作</h1><p>文档：<a href="http://www.redis.cn/commands.html" target="_blank" rel="noopener">http://www.redis.cn/commands.html</a></p><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><ol><li>存储：set key valu</li><li>获取：get key</li><li>删除：del key<h2 id="哈希类型"><a href="#哈希类型" class="headerlink" title="哈希类型"></a>哈希类型</h2></li><li>存储：hset key field value</li><li>获取：hget key field</li><li>删除：hdel key<h2 id="列表类型"><a href="#列表类型" class="headerlink" title="列表类型"></a>列表类型</h2></li><li>将元素加入类别左边：lpush key value</li><li>将元素加入类别右边：rpush key value</li><li>获取<ul><li>lrange key start end：范围获取</li></ul></li><li>删除<ul><li>lpop key:删除列表最左边元素，并将元素返回</li><li>rpop key:删除列表最右边元素，并将元素返回<h2 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h2></li></ul></li><li>存储：sadd key value</li><li>获取所有元素：smember key</li><li>删除某个元素：srem key value<h2 id="有序集合类型"><a href="#有序集合类型" class="headerlink" title="有序集合类型"></a>有序集合类型</h2></li><li>存储：zadd key score value</li><li>获取：zrange key start end</li><li>删除：zren key value<h2 id="通用类型"><a href="#通用类型" class="headerlink" title="通用类型"></a>通用类型</h2></li><li>查询所有键：keys *</li><li>获取键对应的value的类型：type key</li><li>删除指定的key value：del key</li></ol><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>redis是内存数据库，当redis服务器重启，或电脑重启数据会丢失</p><p>redis持久化机制：<br>RDB：默认方式，在一段间隔的时间中检查key变化，然后持久化<br>AOF：日志记录方式，可以每一次命令操作后持久化数据</p><h1 id="Jedis连接池"><a href="#Jedis连接池" class="headerlink" title="Jedis连接池"></a>Jedis连接池</h1><p>创建连接池对象 new JedisPool<br>获取连接 getResource</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rides </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库事务</title>
      <link href="/2020/06/05/shu-ju-ku-shi-wu/"/>
      <url>/2020/06/05/shu-ju-ku-shi-wu/</url>
      
        <content type="html"><![CDATA[<h1 id="事务属性"><a href="#事务属性" class="headerlink" title="事务属性"></a>事务属性</h1><p>原子性：是不可分割的最小单位，要么同时成功要么同时失败<br>持久性：当事务提交或回滚后，数据库会持久化的保存数据<br>隔离性：多个事务直接，相互独立（真实情况下多个事务之间会有影响）<br>一致性：事务操作前后数据总量不变</p><h1 id="mysql开始事务"><a href="#mysql开始事务" class="headerlink" title="mysql开始事务"></a>mysql开始事务</h1><p>start TRANSACTION </p><p>提交<br><br>commit<br><br>回滚<br><br>rollback <br><br>回滚会还原到开启事务之前的状态</p><font color ='red'>在mysql数据库中事务默认自动提交一条DML（增删改）语句会自动提交一次事务</font><p>修改默认提交方式<br>set @@autocommit =   0 – 代表手动提交 1 –代表自动提交</p><h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p>多个事务之间隔离的，相互独立，但如果多个事务操作同一批数据，则会引发一些问题</p><h2 id="存在问题："><a href="#存在问题：" class="headerlink" title="存在问题："></a>存在问题：</h2><p>脏读：一个事务读取到另一个书屋中没有提交的数据<br>不可重复读（虚读）：在同一个事务中两次读取到数据不一样<br>幻读：一个事务操作（DML）数据表中所有记录，另一个事务添加了一条数据，则第一个书屋查询不到自己的修改</p><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>readuncommitted：读未提交</p><ul><li>产生问题：脏读，不可重复读，幻读</li></ul><p>read committed：读已提交（Oracle默认）</p><ul><li>产生问题：不可重复读，幻读</li></ul><p>repeatable read：可重复读（mysql默认）</p><ul><li>产生问题：幻读</li></ul><p>serializable：串行化</p><ul><li>可以解决所有问题</li></ul><font color='red'>注意：隔离级别从小到大安全性越来越高，但效率越来越低</font><p>数据库设置隔离级别</p><p>set global transaction isolation level 级别字符串</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于在SSM框架使用Filter</title>
      <link href="/2020/06/01/guan-yu-zai-ssm-kuang-jia-shi-yong-filter/"/>
      <url>/2020/06/01/guan-yu-zai-ssm-kuang-jia-shi-yong-filter/</url>
      
        <content type="html"><![CDATA[<p>由于Filter创建优先于Spring的实例所以在Filter进行依赖注入是不行的需要使用拦截器</p>]]></content>
      
      
      <categories>
          
          <category> Web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合</title>
      <link href="/2020/05/31/java-ji-he/"/>
      <url>/2020/05/31/java-ji-he/</url>
      
        <content type="html"><![CDATA[<p>集合分为collection和map，<br>Collection是单列集合类的接口，<br>Map是双列集合类的接口</p><h1 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h1><p>collection实现接口有：List  ，Set，Queue</p><p>注：在jdk1.5后添加的Queue</p><h2 id="Collection常用方法"><a href="#Collection常用方法" class="headerlink" title="Collection常用方法"></a>Collection常用方法</h2><p><font color=#DC143C> 注意:Collection方法是没有带索引的方法的</font></p><img src="/2020/05/31/java-ji-he/collection.png" class=""><h2 id="List接口："><a href="#List接口：" class="headerlink" title="List接口："></a>List接口：</h2><ol><li><p>有序的集合</p></li><li><p>允许存储重复的元素</p></li><li><p>有索引，可以使用for循环</p></li></ol><h3 id="List集合包括：ArrayList-，LinkedList，-Vector"><a href="#List集合包括：ArrayList-，LinkedList，-Vector" class="headerlink" title="List集合包括：ArrayList ，LinkedList， Vector"></a>List集合包括：ArrayList ，LinkedList， Vector</h3><ol><li><p>ArrayList：底层是数组实现，查询快，增删慢</p></li><li><p>LinkedList：底层是链表实现的，查询慢，增删快，包含大量操作首尾元素的方法</p></li><li><p>LinkedList还有一个 push（）和pop（）方法等同于addFirst（）和removeFirst（）；</p></li><li><p>Vector：底层结构是数组，线程安全的，增删慢，查询快（不常用）</p></li></ol><p><font color=#DC143C>注意：当使用集合特有方法将无法使用多态</font></p><img src="/2020/05/31/java-ji-he/list.png" class=""><p>注：void add(int index, E element)在列表的指定位置插入指定元素（可选操作）。将当前处于该位置的元素（如果有的话）和所有后续元素向右移动（在其索引中加 1）</p><h2 id="Set接口："><a href="#Set接口：" class="headerlink" title="Set接口："></a>Set接口：</h2><ol><li>不允许存储重复元素如果添加的是已有的数据， 会用现在的值替换原来的值，并返回原来的值</li><li>没有索引，所以不能有for循环</li></ol><h3 id="Set集合包括：HashSet，-LinkedHashSet，-TreeSet"><a href="#Set集合包括：HashSet，-LinkedHashSet，-TreeSet" class="headerlink" title="Set集合包括：HashSet， LinkedHashSet， TreeSet"></a>Set集合包括：HashSet， LinkedHashSet， TreeSet</h3><p>  HashSet：底层是哈希表和红黑树实现的，无索引，不可以存储重复元素，存取无序，存储元素和取出元素可能不一致，查询速度非常快。</p><p>注：当HashSet存储自定义类型元素如String，Integer，Student，Pojo类等</p><p>需要重写hashcode（）和equals（）方法，防止出现对象属性相同但依旧可以存储的情况，应为当自定义的对象的属性相同应该视为同一个对象。</p><p>LinkedHashSet：底层是哈希表和链表实现的，无索引，不可以存储重复元素，可以保证存取顺序</p><p>TreeSet：底层是二叉树实现，一般用于排序</p><p>在jdk1.8之前 ：哈希表=数组+链表</p><p>在jdk1.8之后：哈希表=数组+链表 或 哈希表=数组+红黑树</p><h2 id="Queue接口"><a href="#Queue接口" class="headerlink" title="Queue接口"></a>Queue接口</h2><p>  由于大多数资料没有详细介绍Queue接口所以我单独写了笔记进行介绍</p><h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><p>Map集合键存储键值对，键不可以重复，但值可以重复，但一个键对应一个值</p><p>键和值的数据类型可以相同，也可以不相同</p><p>当添加重复值会替换掉原来的值会返回旧值如果之前不存在则返回null</p><p>注：在Map接口中有一个内部接口Entry，用来记录键与值</p><p>Map实现子类常用的有 HashMap， LinkedHashMap</p><p><img src="/2020/05/31/java-ji-he/map.png" class="" title="}&lt;&#x2F;p&gt; &lt;h2 id&#x3D;HashMap：&gt;&lt;a href&#x3D;#HashMap： class&#x3D;headerlink title&#x3D;HashMap：&gt;&lt;&#x2F;a&gt;HashMap：&lt;&#x2F;h2&gt;&lt;p&gt;1.HashMap集合底层是哈希表，查询速度特别快&lt;&#x2F;p&gt; &lt;p&gt;jdk1.8之前：数组+单向链表&lt;&#x2F;p&gt; &lt;p&gt;jdk1.8之后：数组+单向链表&#x2F;红黑树&lt;&#x2F;p&gt; &lt;p&gt;2.HashMap是一个无序的集合，存储元素和取出元素顺序很可能不一致&lt;&#x2F;p&gt; &lt;p&gt;注：当HashMap存储自定义类型元素作为键时，需要重写hashcode（）和equals（）方法，防止出现对象属性相同但依旧可以存储的情况，应为当自定义的对象的属性相同应该视为同一个对象。&lt;&#x2F;p&gt; &lt;h2 id&#x3D;LinkedHashMap：&gt;&lt;a href&#x3D;#LinkedHashMap： class&#x3D;headerlink title&#x3D;LinkedHashMap：&gt;&lt;&#x2F;a&gt;LinkedHashMap：&lt;&#x2F;h2&gt;&lt;p&gt;1.LinkedHashMap集合底层是哈希表+链表&lt;&#x2F;p&gt; &lt;p&gt;2.LinkHashMap集合底层是有序的集合，存储元素和取出元素顺序是一致&lt;&#x2F;p&gt; &lt;p&gt;3.LinkedHashMap可以根据访问顺序和插入顺序进行排序&lt;&#x2F;p&gt; &lt;h2 id&#x3D;HashTable：&gt;&lt;a href&#x3D;#HashTable： class&#x3D;headerlink title&#x3D;HashTable：&gt;&lt;&#x2F;a&gt;HashTable：&lt;&#x2F;h2&gt;&lt;p&gt;1.键和值都不能为null&lt;&#x2F;p&gt; &lt;p&gt;2.是线程安全的，速度慢&lt;&#x2F;p&gt;">]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/2020/05/31/er-cha-shu/"/>
      <url>/2020/05/31/er-cha-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="2-3查找树"><a href="#2-3查找树" class="headerlink" title="2-3查找树"></a>2-3查找树</h1><p>性质：</p><ol><li>任意空链接到根节点的路径长度都是相等的</li><li>4节点变换为3节点是，树的高度不会发生变化，只有当根节点是临时的4节点时，书高+1。</li><li>2-3树与普通二叉查找树最大的区别在于，普通的二叉查找树是自顶向下生长，而2-3树树自底向上生长</li></ol><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>红黑树主要是对2-3树进行编码，红黑树背后的思想是用标准的二叉查找树和一些额外的信息来表示2-3树</p><p>红链接：将两个2-结点连接起来构成一个3-结点<br>黒链接：是2-3树中的普通链接</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ol><li>红链接均为左连接</li><li>没有任何一个节点同时和两个红链接相连</li><li>该树是完美的黑色平衡，既任意空链接到根节点的路径上黑链接数量相同</li></ol><h2 id="红黑树结点API"><a href="#红黑树结点API" class="headerlink" title="红黑树结点API"></a>红黑树结点API</h2><ol><li>public Node lef:记录左子结点<br /></li><li>public Node right:记录右子结点<br/></li><li>public Key key;存储键<br/></li><li>public Value value:存储值<br/></li><li>public boolean color:由其父结点指向它的链接的颜色</li></ol><p>注：有些红黑树的结点是红色和黑色而不是链接是红色或黑色<br>红色结点代表其父结点跟当且结点的链接是红色的</p><p>根节点颜色总是黑色</p><p>当结点右链接为红色则进行左旋</p><p>当结点左连接是红色并且左连接的左连接还是红色则右旋</p><p>当右旋后结点的左右链接都为红色则进行颜色翻转左右链接变为黑色，该节点变为红色</p><h1 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h1><p>B-树是M介树则每个节点存放的值不能超过M-1个</p><p>应用于磁盘</p><h1 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h1><p>B+树和B-树一样每个节点不可超过M-1个<br>B+树的非叶子节点不存放值只存放键</p><p>应用于数据库</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存</title>
      <link href="/2020/05/30/jvm-nei-cun/"/>
      <url>/2020/05/30/jvm-nei-cun/</url>
      
        <content type="html"><![CDATA[<p>栈（虚拟机栈）：存放局部变量，并且方法的运行一定在栈中<br>堆：凡是new出来的东西都在栈中<br>方法区：存储.class相关信息，包含方法的信息<br>本地方法栈：与操作系统相关<br>程序计数器（寄存器）：与cpu相关<br>这五大内存区统称为运行时数据区<br>其中栈，程序计数器，本地方法区时线程私有的，随着线程启动而创建，而堆和方法区时共有的，随线程启动而创建</p><h2 id="程序计数器："><a href="#程序计数器：" class="headerlink" title="程序计数器："></a>程序计数器：</h2><p>记住下一条jvm指令的执行地址<br>在物理上通过cpu寄存器实现的<br>程序计数器是私有的，每个线程有自己的程序计数器不会存在内存溢出</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>线程运行需要的内存空间<br>栈是线程私有的<br>栈由栈帧组成，每个栈帧代表一次方法的调用（栈帧也可以说是每个方法的内存）每个线程只有一个活动栈帧（线程正在执行的方法）<br>注意：<br> &emsp;    1. 当方法执行完毕后会自动弹出栈，所以垃圾回收不涉及栈内存<br>   &emsp;        2. 栈可以通过调节大小，但栈越大同时运行的线程越少<br>   &emsp;      3.方法内定义的局部变量是线程安全的</p><p>   注：如果方法内局部变量没有逃离方法的作用范围，他是线程安全的如果局部变量变量引用，并逃离方法的作用范围，需要考虑线程安全</p><p>栈内存溢出：<br>&emsp;1.栈帧过多（例如递归调用没有设置好结束条件会不断调用自身并且不会结束）<br>&emsp;2.栈帧过大（很少出现）</p><h2 id="本地方法栈："><a href="#本地方法栈：" class="headerlink" title="本地方法栈："></a>本地方法栈：</h2><p>本地方法使用的内存<br>栈是线程私有的<br>本地方法（如hashcode，clone）是指不是Java代码编写的方法，由于有时候Java无法与系统层进行操作，所以会调用用c或c++编写的方法进行对系统的操作</p><h2 id="堆："><a href="#堆：" class="headerlink" title="堆："></a>堆：</h2><p>通过new关键字，创建对象都会使用堆内存<br>线程共享的，需要考虑线程安全<br>有垃圾回收机制</p><h2 id="方法区："><a href="#方法区：" class="headerlink" title="方法区："></a>方法区：</h2><p>存储类结构相关信息：成员变量，方法数据，成员方法和构造器代码，类构造器，运行时常量池）虚拟机启动时创建，逻辑上是堆的一部分（但不同厂商可能不同）（在1.8被称作元空间，放在内存中而不是jvm内，不占用堆内存）</p><p>线程共享的，需要考虑线程安全</p><p>存在内存溢出（规范规定方法区可以不实现垃圾收集）</p><h2 id="直接内存："><a href="#直接内存：" class="headerlink" title="直接内存："></a>直接内存：</h2><p>不属于JVM内存，而是操作系统的内存<br>常见与NIO操作，用于数据缓冲区分配<br>回收代价大，但读写性能高，不受JVM内存回收管理，需要自己回收。</p><p>以上为个人整理发布</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串方法</title>
      <link href="/2020/05/30/zi-fu-chuan-fang-fa/"/>
      <url>/2020/05/30/zi-fu-chuan-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>一、字符串的检索方法</p><p>1、charAt()</p><p>2、charCodeAt()</p><p>3、indexOf()</p><p>4、lastIndexOf()</p><p>chatAt()</p><p>语法：stringObject.charAt(index)</p><p>功能：返回stringObject中index位置的字符，如果没有返回空。</p><p>charCodeAt()</p><p>语法：stringObject.charCodeAt()</p><p>功能：返回stringObject中index位置的字符编码。</p><p>indexOf()</p><p>语法：stringObjet.indexOf(‘需要查找的字符’)</p><p>功能：从左往右在一个字符串中搜索给定的字符串，返回子字符串的位置。</p><p>返回值：是number值，如果不存在，就返回-1。</p><p>lastIndexOf()</p><p>语法：stringObject.lastIndexOf(‘需要查找的字符’)</p><p>功能：从右往左在一个字符串中搜索给定的字符串，返回子字符串的位置。</p><p>返回值：是number类型，如果不存在，就返回-1。</p><p>二、字符串的截取方法</p><p>1、slice()</p><p>2、substring()</p><p>3、substr()</p><p>slice()</p><p>语法：stringObject.slice(start,end)</p><p>功能：截取字符串。</p><p>参数：</p><p>start：（必须）指定子字符串的开始位置。</p><p>end：（可选）表示子字符串到哪里结束，end本身不在截取范围之内，省略不写时候直接截取至字符串末尾。</p><p>当参数为负数时候，会将传入的负值与字符串的长度相加。</p><p>substring()</p><p>语法及功能同slice()完全一样，区别只在于遇到负数时，自动将参数转换为0。</p><p>substring()会把较小的数作为开始位置，较大的数作为结束位置。</p><p>substr()</p><p>语法：stringObiect.substr(start,len)</p><p>功能：截取字符串</p><p>参数说明：</p><p>start ：（必需）指定字符串的开始位置；</p><p>len：（可选）表示截取的字符总数，省略时截取至字符串的末尾。</p><p>当start为负数时，会将传入的负值与字符串的长度相加。</p><p>当len为负数时返回空字符串。</p><p>三、字符串对象的方法</p><p>split()</p><p>replace()</p><p>split() 把一个字符串分割成字符串数组</p><p>语法：stringObject.split(separator)</p><p>返回值：Array</p><p>参数：separator（必须）分隔符</p><p>replace()</p><p>语法：stringObject.replace(regexp/substr,replacement)</p><p>功能：在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。只能替换第一个不能替换全部</p><p>返回值：string</p><p>参数：</p><p>regexp:（必需）规定子字符串或者要替换的模式的RegExp对象。</p><p>replacement:（必需）一个字符串值</p><p>注意：不会修改原字符串，会返回一个新的字符串。</p><p>四、字符串转换大小写方法</p><p>toUpperCase()</p><p>toLowerCase()</p><p>toUpperCase()</p><p>将字符串转换为大写</p><p>返回值：返回一个新字符串，不修改原字符串</p><p>toLowerCase()</p><p>将字符串转换为小写</p><p>返回值：返回一个新字符串，不修改原字符串</p><p>转载自：</p><p><a href="https://www.jianshu.com/p/3200b0e07cb5" target="_blank" rel="noopener">https://www.jianshu.com/p/3200b0e07cb5</a></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Java的常量池，运行时常量池，和串池（字符串常量池）</title>
      <link href="/2020/05/30/guan-yu-java-de-chang-liang-chi-yun-xing-shi-chang-liang-chi-he-chuan-chi-zi-fu-chuan-chang-liang-chi/"/>
      <url>/2020/05/30/guan-yu-java-de-chang-liang-chi-yun-xing-shi-chang-liang-chi-he-chuan-chi-zi-fu-chuan-chang-liang-chi/</url>
      
        <content type="html"><![CDATA[<h1 id="常量池："><a href="#常量池：" class="headerlink" title="常量池："></a>常量池：</h1><p>常量池：常量池是*.clsaa文件中的，就是一张表，存储常量符号，虚拟指令可以这些常量符号来查找类或方法或类型。</p><p>运行时常量池：当类被加载，它的常量池信息就会放入方法区的运行时常量池，并把里面的符号地址变为真实地址。</p><h2 id="StringTable（串池）hashtable结构，不能扩容："><a href="#StringTable（串池）hashtable结构，不能扩容：" class="headerlink" title="StringTable（串池）hashtable结构，不能扩容："></a>StringTable（串池）hashtable结构，不能扩容：</h2><p>在jdk1.8时串池再堆区中</p><p>jdk1.7把串池移除方法区</p><p>运行时常量池的字符串仅是符号，还没有变为对象，第一次用的才变为对象并且放入串池中</p><p>利用串池机制，来避免创建重复字符串对象</p><p>常量字符串并不会直接创建，而是引用到位置时在创建串池字符串对象</p><p>当字符串变量进行进行拼接时会创建一个stringbuilder对象（1.8）进行拼接，并调用 toString（）方法返回一个字符串对象（在堆中存储的）</p><p>当字符串常量进行拼接时会在编译期间进行优化会直接对字符串进行拼接，在运行期间在串池查找是否存在一样的字符串再返回引用</p><p>1.8中intern（）方法可以将字符串对象放入串池，如果已存在则不放入，返回串池的对象</p><p>1.6中intern（）方法方法可以将字符串对象放入串池，如果已存在则不放入，没有则将对象复制一份放入串池，返回串池的对象</p><p>在JVM1.6串池是常量池的一部分存储在方法区（永久代）内</p><p>在JVM1.7中串池放在堆中</p><p>垃圾回收:由于在常量区内会进行垃圾回收</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>StringBuilder和StringBuffer</title>
      <link href="/2020/05/30/stringbuilder-he-stringbuffer/"/>
      <url>/2020/05/30/stringbuilder-he-stringbuffer/</url>
      
        <content type="html"><![CDATA[<p>StringBuffer是线程安全的，但速度慢</p><p>StringBuilder是线程不安全，但速度快</p><p>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Web文件下载</title>
      <link href="/2020/05/30/web-wen-jian-xia-zai/"/>
      <url>/2020/05/30/web-wen-jian-xia-zai/</url>
      
        <content type="html"><![CDATA[<p>需要工具类：commons-io-2.6-bin和commons-fileupload-1.4-bin</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doPost</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">)</span> throws ServletException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>    String name <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//解决获得中文参数的乱码</span>    name <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"ISO8859-1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//美女.jpg</span>    <span class="token comment" spellcheck="true">//获得请求头中的User-Agent</span>    String agent <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token string">"User-Agent"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//根据不同浏览器进行不同的编码</span>    String fileNameEncoder <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>agent<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"MSIE"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// IE浏览器</span>        fileNameEncoder <span class="token operator">=</span> URLEncoder<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        fileNameEncoder <span class="token operator">=</span> fileNameEncoder<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"+"</span><span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>agent<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"Firefox"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 火狐浏览器</span>        BASE64Encoder base64Encoder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BASE64Encoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        fileNameEncoder <span class="token operator">=</span> <span class="token string">"=?utf-8?B?"</span> <span class="token operator">+</span> base64Encoder<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"?="</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 其它浏览器</span>        fileNameEncoder <span class="token operator">=</span> URLEncoder<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    response<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span><span class="token string">"text/html;charset=utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ServletContext servletContext <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getServletContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    InputStream fileInputStream <span class="token operator">=</span> servletContext<span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"/file/"</span><span class="token operator">+</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    String minmeType <span class="token operator">=</span> servletContext<span class="token punctuation">.</span><span class="token function">getMimeType</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">"content-type"</span><span class="token punctuation">,</span>minmeType<span class="token punctuation">)</span><span class="token punctuation">;</span>    response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">"content-disposition"</span><span class="token punctuation">,</span><span class="token string">"attachment;filename="</span><span class="token operator">+</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    OutputStream sos <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    byte<span class="token punctuation">[</span><span class="token punctuation">]</span> buff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    int len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>len <span class="token operator">=</span> fileInputStream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buff<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>buff<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        sos<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buff<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    fileInputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传</title>
      <link href="/2020/05/30/wen-jian-shang-chuan/"/>
      <url>/2020/05/30/wen-jian-shang-chuan/</url>
      
        <content type="html"><![CDATA[<p>实现文件上传必须把<from>设置为enctype=”multipart/form-data” 请求方式为post如</p><pre class=" language-javascript"><code class="language-javascript"> <span class="token operator">&lt;</span>form id<span class="token operator">=</span><span class="token string">""</span>   action<span class="token operator">=</span><span class="token string">""</span> method<span class="token operator">=</span><span class="token string">"post"</span>  enctype<span class="token operator">=</span><span class="token string">"multipart/form-data"</span><span class="token operator">></span> </code></pre><h1 id="传统文件上传"><a href="#传统文件上传" class="headerlink" title="传统文件上传"></a>传统文件上传</h1><p>需要工具类：commons-io-2.6-bin和commons-fileupload-1.4-bin</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fileUp</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//让浏览器用utf8来解析返回的数据</span>response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">"Content-type"</span><span class="token punctuation">,</span> <span class="token string">"text/html;charset=UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//告诉servlet用UTF-8转码，而不是用默认的ISO8859</span>response<span class="token punctuation">.</span><span class="token function">setCharacterEncoding</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//解决文件名</span>request<span class="token punctuation">.</span><span class="token function">setCharacterEncoding</span><span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//获取路径</span>    String path <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//判断路径是否存在</span>    File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>file<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//创建文件</span>        file<span class="token punctuation">.</span><span class="token function">mkdir</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//解析request对象，获取上传文件项</span>        DiskFileItemFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DiskFileItemFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//设置缓冲区大小</span>        factory<span class="token punctuation">.</span><span class="token function">setSizeThreshold</span><span class="token punctuation">(</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//设置临时文件路径</span>        factory<span class="token punctuation">.</span><span class="token function">setRepository</span><span class="token punctuation">(</span>tempFile<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建文件上传处理器</span>        ServletFileUpload upload <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SerletFileUpload</span><span class="token punctuation">(</span>factory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//解决上传文件名的中文乱码</span>        upload<span class="token punctuation">.</span><span class="token function">setHeaderEncoding</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//设置上传单个文件的大小的最大值，目前是设置为1024*1024字节，也就是600MB</span>        upload<span class="token punctuation">.</span><span class="token function">setFileSizeMax</span><span class="token punctuation">(</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//设置上传文件总量的最大值，最大值=同时上传的多个文件的大小的最大值的和，目前设置为1000MB</span>        upload<span class="token punctuation">.</span><span class="token function">setSizeMax</span><span class="token punctuation">(</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//解析request</span>        List items <span class="token operator">=</span> upload<span class="token punctuation">.</span><span class="token function">parseRequest</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//遍历</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>FileItem item <span class="token punctuation">:</span> items<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//进行判断，当前item对象是否是上传文件项</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span><span class="token function">isFormField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//说明是普通表的项</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//说明是上传文件项</span>                <span class="token comment" spellcheck="true">//获取上传文件名称</span>                String filename <span class="token operator">=</span> item<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//处理不同浏览器传来的文件名问题</span>                int index<span class="token operator">=</span>name<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">"\\"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>index<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    filename<span class="token operator">=</span>name<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//完成文件上传</span>                item<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span>filename<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//删除临时文件</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="SpringMVC文件上传"><a href="#SpringMVC文件上传" class="headerlink" title="SpringMVC文件上传"></a>SpringMVC文件上传</h1><p>先SpringMVC配置文件解析器</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 文件解析器<span class="token operator">--</span><span class="token operator">></span> <span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"multipartResolver"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span><span class="token operator">></span>       <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"maxUploadSize"</span> value<span class="token operator">=</span><span class="token string">"10485760"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">></span></code></pre><p>例子一</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">public</span> String <span class="token function">handler</span><span class="token punctuation">(</span>@<span class="token function">RequestParam</span><span class="token punctuation">(</span><span class="token string">"uploadfile"</span><span class="token punctuation">)</span> List uploadfile<span class="token punctuation">,</span> HttpServletRequest request<span class="token punctuation">)</span> throws IOException <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"进入servlet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>uploadfile<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>uploadfile<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//循环输出上传文件</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>MultipartFile file <span class="token punctuation">:</span> uploadfile<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//获取上传文件原始名称</span>            String filename <span class="token operator">=</span> file<span class="token punctuation">.</span><span class="token function">getOriginalFilename</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//设置保存目录</span>            String dirPath <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getServletContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getRealPath</span><span class="token punctuation">(</span><span class="token string">"/upload/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            File filePath <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>dirPath<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>filePath<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                filePath<span class="token punctuation">.</span><span class="token function">mkdirs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//重新命名上传文件名称</span>            String newFilename<span class="token operator">=</span><span class="token string">"1"</span><span class="token operator">+</span>filename<span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"上传成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//完成文件上传</span>            file<span class="token punctuation">.</span><span class="token function">transferTo</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>dirPath<span class="token operator">+</span>newFilename<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token string">"success.jsp"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>例子二</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">public</span> String <span class="token function">addProduct</span><span class="token punctuation">(</span>MultipartFile upload<span class="token punctuation">,</span> Products product<span class="token punctuation">,</span> HttpServletRequest request<span class="token punctuation">)</span> throws IOException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//文件保存路径</span>    String path <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getServletContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getRealPath</span><span class="token punctuation">(</span><span class="token string">"/client/bookcover/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//数据库保存路径</span>    String dataUrl <span class="token operator">=</span> <span class="token string">"/client/bookcover/"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//获取文件名</span>    String fileName <span class="token operator">=</span> upload<span class="token punctuation">.</span><span class="token function">getOriginalFilename</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//完成上传</span>    upload<span class="token punctuation">.</span><span class="token function">transferTo</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span>fileName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token string">"/listProduct"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网路层</title>
      <link href="/2020/05/05/wang-lu-ceng/"/>
      <url>/2020/05/05/wang-lu-ceng/</url>
      
        <content type="html"><![CDATA[<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>32位组成，分为网络号和主机号</p><h4 id="各类IP地址"><a href="#各类IP地址" class="headerlink" title="各类IP地址"></a>各类IP地址</h4><ol><li>A类地址为网络号8位开头为0，第一个可指派网络号1，最后一个可指派网络号126</li><li>B类地址网络号16位开头为10，第一个可指派网络号128.1，最后一个可指派网络号191.255</li><li>C类地址网络号24位开头为110，第一个可指派网络号192.0.1，最后一个可指派网络号223.255.255</li></ol><p>通常将8位为一组转换为10进制数</p><h4 id="特殊的IP地址"><a href="#特殊的IP地址" class="headerlink" title="特殊的IP地址"></a>特殊的IP地址</h4><ol><li>网络号全0和主机号全0，值本网络上的本主机<br>源地址可以使用，目的地址不可使用</li><li>网络号全0，指在本网络上的某台主机，源地址可以使用，目的地址不可使用</li><li>网络号全1主机号全1，指对本网络上所有主机进行广播，源地址不可使用，目的地址可以使用</li><li>主机号全1，对相应网络上的所有主机进行广播，源地址不可使用，目的地址可以使用</li><li>网络号127，主机号非全0或全1的任何数，用于本地软件的环回测试<h3 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h3>作用：从网络层使用的ip地址，解析出在数据链路层所使用的硬件地址</li></ol><p>每个主机都设有一个ARP高速缓存，里面有所在局域网上的各主机和路由器IP地址到硬件地址映射表</p><p>当主机向本局域网发送IP数据报时，先从ARP高速缓存中查看有无目的主机的IP地址，如果有，就查出对应硬件地址，如果没有，就在本局域网广播发送一个ARP请求分组，得到ARP响应分组后，将得到的IP地址到硬件地址的映射写入ARP高速缓存</p><h3 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h3><p>在IP地址中增加一个子网号字段使两级的IP变为三级IP地址</p><p>从主机号借用若干位作为子网号</p><p>从其他网络发送给本单位某个主机的IP数据包，先找到本单位网络上的路由器，然后此路由器在收到IP数据报后，再按目的网络号和子网号找到目的子网最后将IP数据包交付目的主机</p><p>使用子网掩码可以找出IP地址中的子网部分</p><ol><li>子网掩码长度32位</li><li>子网掩码左边部分一串1，对应网络号和子网号</li><li>子网掩码右边部分一串0，对应于主机号</li></ol><p>注：根据互联网标准协议，子网号不能全0或全1，但随着无份类域间路由选择CIDR的广泛使用，现在全0或全1的子网号也可以使用</p><p>子网划分增加类灵活性但也减少了主机数</p><h4 id="无分类域间路由选择CIDR"><a href="#无分类域间路由选择CIDR" class="headerlink" title="无分类域间路由选择CIDR"></a>无分类域间路由选择CIDR</h4><p>使用各种长度的网络前缀来代替分类地址中的网络号和子网号</p><p>IP地址从三级编址又回到了两级编址</p><p>CIDR使用斜线记法，又称为CIDR记法，在IP地址后加上一个斜线，然后写上网络前缀所占位数</p><p>CIDR把网络前缀都相同的连续IP地址组成CIDR地址块</p><p>路由聚合：</p><ol><li>一个CIDR地址块可以表示很多地址，这种地址的聚合常称为路由聚合，它使路由表中的一个项目可以表示很多个原来传统分类地址的路由</li><li>路由聚合有利于减少路由器之间的路由选择信息交换，从而提高了整个互联网的性能</li><li>路由聚合也成为构成超网</li></ol><p>最长前缀匹配：使用CIDR时路由表中，在查找路由表时可能会得到不止一个匹配结果，应当从匹配结果中选择具有最长网络前缀的路由这种方式称为，最长前缀匹配</p><h3 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h3><p>为了更有效的转发IP数据报和提高交付成功的机会，在网际层使用ICMP，ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告</p><h3 id="网际组管理协议IGMP"><a href="#网际组管理协议IGMP" class="headerlink" title="网际组管理协议IGMP"></a>网际组管理协议IGMP</h3><p>作用于多播中，多播数据包也是尽最大努力交付，不保证一定能够交付多播组内的所有成员，对多播数据报不产生ICMP差错报是否有主机（严格讲，是主机上某个进程）参加或退出了莫格多播组</p><p>IGMP协议是让连接在本地局域网上的多播路由器知道本局域网上shi</p><h3 id="内部网关协议IGP"><a href="#内部网关协议IGP" class="headerlink" title="内部网关协议IGP"></a>内部网关协议IGP</h3><h4 id="路由信息协议RIP"><a href="#路由信息协议RIP" class="headerlink" title="路由信息协议RIP"></a>路由信息协议RIP</h4><p>是一种分布式，基于距离向量的路由选择协议</p><p>RIP要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录</p><p>RIP允许一条路径最多只能包含15个路由器，距离最大值为16即相当于不可达</p><p>RIP不能在两个网络之间同时使用多条路由<br>特点：</p><ol><li>仅和相邻路由器交换信息</li><li>交换的信息是当前本路由器所知道的全部信息</li><li>按固定的时间间隔交换</li></ol><p>存在问题：当网络出现故障时，要经过比较长的时间才能将此信息传到所有路由器<br>优点：实现简单，开销小</p><p>缺点：</p><ol><li>限制了网络的规模</li><li>路由器之间交换的路由信息是路由器中完整的路由表，因而随着网络规模的扩大，开销也就增加</li><li>坏消息传得慢，使更新过程的收敛时间 过长</li></ol><h4 id="内部网关协议OSPF"><a href="#内部网关协议OSPF" class="headerlink" title="内部网关协议OSPF"></a>内部网关协议OSPF</h4><p>开放最短路径优先<br>OSPF不用UDP而是直接用IP数据报传送</p><p>OSPF规定每隔一段时间，要刷新一次数据库中的链路状态</p><p>当互联网规模很大时，OSPF协议要比距离向量协议RIP好的多</p><h3 id="外部网关协议EGP"><a href="#外部网关协议EGP" class="headerlink" title="外部网关协议EGP"></a>外部网关协议EGP</h3><h4 id="边界网关协议BGP"><a href="#边界网关协议BGP" class="headerlink" title="边界网关协议BGP"></a>边界网关协议BGP</h4><p>力求寻找一条能够达到目的网络且比较好的路由，并非要寻找一条最佳路由</p><p>BGP支持CIDR，在BGP刚刚运行时，BGP的邻站时交换整个BGP路由表，但以后只需要在发生变化时更新有变化的部分。这样做对节省网络带宽和减少路由器开销都有好处</p><h4 id="虚拟专用网VPN"><a href="#虚拟专用网VPN" class="headerlink" title="虚拟专用网VPN"></a>虚拟专用网VPN</h4><p>在RFC1918指明了一些专用地址。专用地址只能用作本地地址而不能用作全球地址。在互联网中的所有路由器，对目的地址是专用地址的数据报一律不进行转发</p><p>三个专用地址块：</p><ol><li>10.0.0.0到10.255.255.255</li><li>172.16.0.0到172.31.255.255</li><li>192.168.0.0到192.168.255.255</li></ol><p>采用这样的专用IP地址的互联网络称为专用互联网或本地互联网，简单些叫专用网</p><p>因为这些专用地址尽在本机构内部使用，专用IP地址也叫做可重用地址</p><p>远程接入VPN可以满足外部流动员工访问公司网络需求，专用的VPN软件可以在员工PC机和公司的主机之间建立VPN隧道</p><h3 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h3><p>在专用网连接到互联网的路由器上安装NAT软件。装有NAT软件的路由器叫NAT路由器，他<br><font color = 'red'><br>至少有一个有效的外部全球IP地址。<br></font><br>所有使用本地地址的主机在和外界通信时，都要在NAT路由器上<br><font color = 'red'><br>将其本地地址转换成全球IP地址，才能和互联网互联<br></font></p><p>为了更加有效的利用NAT路由器上的全球IP地址，现在常用的NAT转换表把运输层端口号也利用上。这样，就可以使多个拥有本地地址的主机，共用一个NAT路由器的全球IP地址。使用端口号NAT叫做网络地址与端口号转换NAPT</p><h3 id="多协议标记交换MPLS"><a href="#多协议标记交换MPLS" class="headerlink" title="多协议标记交换MPLS"></a>多协议标记交换MPLS</h3><p>为每个分组携带一个整数标记，当分组达到交换机时，交换机读取分组标记，并用标记值来检索分组转发表。</p><p>MPLS并没有取代IP，而是作为一种IP增强技术。</p><p>特点：</p><ol><li>支持面向连接的服务质量。</li><li>支持流量工程，平衡网络负载。</li><li>有效地支持虚拟专用网VPN</li></ol><p>原理：<br>在MPLS入口处，给每一个IP数据报打上固定长度标记，然后对打上标记的IP数据包用硬件进行转发。<br>采用硬件技术对打上标记的IP数据报进行转发就成为标记交换。</p><p>交换也表示在转发时不再上升到第三层查找转发表，而是而是根据标记在第二层（链路层）用硬件进行转发</p><p>支持MPLS技术的标记交换路由器LSR</p><p>LSR同时具有标记交换和路由选择两种功能，标记交换功能是为了快速转发，<br><font color = 'red'><br>但在这之前LSR需要使用路由选择功能构造转发表<br></font></p><p>工作过程：</p><ol><li>MPLS域中的各LSR使用专门的标记分配协议LDP交换报文，并找出标记交换路径LSP。各LSR根据这些路径构造出分组转发表。</li><li>分组进入MPLS域时，MPLS入口节点把分组打上标记，并按照转发表将分组转发给下一个LSR。给IP数据报打标记的过程叫做分类</li></ol><p>转发等价类就是路由器按照同样方式对待分组的集合</p><p>按照同样方式对待表示：从同样接口转发到同样下一跳地址，并且具有同样服务类别和同样丢弃优先级等</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
